[
  {
    "id": "absurd_extreme_comparisons",
    "id_span": {
      "path": "src/absurd_extreme_comparisons.rs",
      "line": 39
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for comparisons where one side of the relation is\neither the minimum or maximum value for its type and warns if it involves a\ncase that is always true or always false. Only integer and boolean types are\nchecked.\n\n### Why is this bad?\nAn expression like `min <= x` may misleadingly imply\nthat it is possible for `x` to be less than the minimum. Expressions like\n`max < x` are probably mistakes.\n\n### Known problems\nFor `usize` the size of the current compile target will\nbe assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\na comparison to detect target pointer width will trigger this lint. One can\nuse `mem::sizeof` and compare its value or conditional compilation\nattributes\nlike `#[cfg(target_pointer_width = \"64\")] ..` instead.\n\n### Example\n```rust\nlet vec: Vec<isize> = Vec::new();\nif vec.len() <= 0 {}\nif 100 > i32::MAX {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "almost_swapped",
    "id_span": {
      "path": "src/swap.rs",
      "line": 63
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `foo = bar; bar = foo` sequences.\n\n### Why is this bad?\nThis looks like a failed attempt to swap.\n\n### Example\n```rust\na = b;\nb = a;\n```\nIf swapping is intended, use `swap()` instead:\n```rust\nstd::mem::swap(&mut a, &mut b);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "approx_constant",
    "id_span": {
      "path": "src/approx_const.rs",
      "line": 36
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for floating point literals that approximate\nconstants which are defined in\n[`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants)\nor\n[`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants),\nrespectively, suggesting to use the predefined constant.\n\n### Why is this bad?\nUsually, the definition in the standard library is more\nprecise than what people come up with. If you find that your definition is\nactually more precise, please [file a Rust\nissue](https://github.com/rust-lang/rust/issues).\n\n### Example\n```rust\nlet x = 3.14;\nlet y = 1_f64 / x;\n```\nUse predefined constants instead:\n```rust\nlet x = std::f32::consts::PI;\nlet y = std::f64::consts::FRAC_1_PI;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "as_conversions",
    "id_span": {
      "path": "src/as_conversions.rs",
      "line": 41
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `as` conversions.\n\nNote that this lint is specialized in linting *every single* use of `as`\nregardless of whether good alternatives exist or not.\nIf you want more precise lints for `as`, please consider using these separate lints:\n`unnecessary_cast`, `cast_lossless/possible_truncation/possible_wrap/precision_loss/sign_loss`,\n`fn_to_numeric_cast(_with_truncation)`, `char_lit_as_u8`, `ref_to_mut` and `ptr_as_ptr`.\nThere is a good explanation the reason why this lint should work in this way and how it is useful\n[in this issue](https://github.com/rust-lang/rust-clippy/issues/5122).\n\n### Why is this bad?\n`as` conversions will perform many kinds of\nconversions, including silently lossy conversions and dangerous coercions.\nThere are cases when it makes sense to use `as`, so the lint is\nAllow by default.\n\n### Example\n```rust\nlet a: u32;\n...\nf(a as u16);\n```\n\nUsually better represents the semantics you expect:\n```rust\nf(a.try_into()?);\n```\nor\n```rust\nf(a.try_into().expect(\"Unexpected u16 overflow in f\"));\n```\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "assertions_on_constants",
    "id_span": {
      "path": "src/assertions_on_constants.rs",
      "line": 29
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `assert!(true)` and `assert!(false)` calls.\n\n### Why is this bad?\nWill be optimized out by the compiler or should probably be replaced by a\n`panic!()` or `unreachable!()`\n\n### Known problems\nNone\n\n### Example\n```rust\nassert!(false)\nassert!(true)\nconst B: bool = false;\nassert!(B)\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "assign_op_pattern",
    "id_span": {
      "path": "src/assign_ops.rs",
      "line": 37
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `a = a op b` or `a = b commutative_op a`\npatterns.\n\n### Why is this bad?\nThese can be written as the shorter `a op= b`.\n\n### Known problems\nWhile forbidden by the spec, `OpAssign` traits may have\nimplementations that differ from the regular `Op` impl.\n\n### Example\n```rust\nlet mut a = 5;\nlet b = 0;\n// ...\n// Bad\na = a + b;\n\n// Good\na += b;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "assign_ops",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 95
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis lint is too subjective, not having a good reason for being in clippy.\nAdditionally, compound assignment operators may be overloaded separately from their non-assigning\ncounterparts, so this lint may suggest a change in behavior or the code may not compile.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "async_yields_async",
    "id_span": {
      "path": "src/async_yields_async.rs",
      "line": 37
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for async blocks that yield values of types\nthat can themselves be awaited.\n\n### Why is this bad?\nAn await is likely missing.\n\n### Example\n```rust\nasync fn foo() {}\n\nfn bar() {\n  let x = async {\n    foo()\n  };\n}\n```\nUse instead:\n```rust\nasync fn foo() {}\n\nfn bar() {\n  let x = async {\n    foo().await\n  };\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "await_holding_lock",
    "id_span": {
      "path": "src/await_holding_invalid.rs",
      "line": 50
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for calls to await while holding a\nnon-async-aware MutexGuard.\n\n### Why is this bad?\nThe Mutex types found in std::sync and parking_lot\nare not designed to operate in an async context across await points.\n\nThere are two potential solutions. One is to use an async-aware Mutex\ntype. Many asynchronous foundation crates provide such a Mutex type. The\nother solution is to ensure the mutex is unlocked before calling await,\neither by introducing a scope or an explicit call to Drop::drop.\n\n### Known problems\nWill report false positive for explicitly dropped guards ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)).\n\n### Example\n```rust\nuse std::sync::Mutex;\n\nasync fn foo(x: &Mutex<u32>) {\n  let guard = x.lock().unwrap();\n  *guard += 1;\n  bar.await;\n}\n```\n\nUse instead:\n```rust\nuse std::sync::Mutex;\n\nasync fn foo(x: &Mutex<u32>) {\n  {\n    let guard = x.lock().unwrap();\n    *guard += 1;\n  }\n  bar.await;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "await_holding_refcell_ref",
    "id_span": {
      "path": "src/await_holding_invalid.rs",
      "line": 91
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for calls to await while holding a\n`RefCell` `Ref` or `RefMut`.\n\n### Why is this bad?\n`RefCell` refs only check for exclusive mutable access\nat runtime. Holding onto a `RefCell` ref across an `await` suspension point\nrisks panics from a mutable ref shared while other refs are outstanding.\n\n### Known problems\nWill report false positive for explicitly dropped refs ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)).\n\n### Example\n```rust\nuse std::cell::RefCell;\n\nasync fn foo(x: &RefCell<u32>) {\n  let mut y = x.borrow_mut();\n  *y += 1;\n  bar.await;\n}\n```\n\nUse instead:\n```rust\nuse std::cell::RefCell;\n\nasync fn foo(x: &RefCell<u32>) {\n  {\n     let mut y = x.borrow_mut();\n     *y += 1;\n  }\n  bar.await;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "bad_bit_mask",
    "id_span": {
      "path": "src/bit_mask.rs",
      "line": 44
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for incompatible bit masks in comparisons.\n\nThe formula for detecting if an expression of the type `_ <bit_op> m\n<cmp_op> c` (where `<bit_op>` is one of {`&`, `|`} and `<cmp_op>` is one of\n{`!=`, `>=`, `>`, `!=`, `>=`, `>`}) can be determined from the following\ntable:\n\n|Comparison  |Bit Op|Example     |is always|Formula               |\n|------------|------|------------|---------|----------------------|\n|`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n|`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n|`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n|`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n|`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n|`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n\n### Why is this bad?\nIf the bits that the comparison cares about are always\nset to zero or one by the bit mask, the comparison is constant `true` or\n`false` (depending on mask, compared value, and operators).\n\nSo the code is actively misleading, and the only reason someone would write\nthis intentionally is to win an underhanded Rust contest or create a\ntest-case for this lint.\n\n### Example\n```rust\nif (x & 1 == 2) { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "bind_instead_of_map",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 461
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.and_then(|x| Some(y))`, `_.and_then(|x| Ok(y))` or\n`_.or_else(|x| Err(y))`.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.map(|x| y)` or `_.map_err(|x| y)`.\n\n### Example\n```rust\nlet _ = opt().and_then(|s| Some(s.len()));\nlet _ = res().and_then(|s| if s.len() == 42 { Ok(10) } else { Ok(20) });\nlet _ = res().or_else(|s| if s.len() == 42 { Err(10) } else { Err(20) });\n```\n\nThe correct use would be:\n\n```rust\nlet _ = opt().map(|s| s.len());\nlet _ = res().map(|s| if s.len() == 42 { 10 } else { 20 });\nlet _ = res().map_err(|s| if s.len() == 42 { 10 } else { 20 });\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "blacklisted_name",
    "id_span": {
      "path": "src/blacklisted_name.rs",
      "line": 20
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of blacklisted names for variables, such\nas `foo`.\n\n### Why is this bad?\nThese names are usually placeholder names and should be\navoided.\n\n### Example\n```rust\nlet foo = 3.14;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `blacklisted-names`: `Vec<String>`: The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses (defaults to `[\"foo\", \"baz\", \"quux\"]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "blanket_clippy_restriction_lints",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 180
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n\n### Why is this bad?\nRestriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\nThese lints should only be enabled on a lint-by-lint basis and with careful consideration.\n\n### Example\nBad:\n```rust\n#![deny(clippy::restriction)]\n```\n\nGood:\n```rust\n#![deny(clippy::as_conversions)]\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "blocks_in_if_conditions",
    "id_span": {
      "path": "src/blocks_in_if_conditions.rs",
      "line": 44
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `if` conditions that use blocks containing an\nexpression, statements or conditions that use closures with blocks.\n\n### Why is this bad?\nStyle, using blocks in the condition makes it hard to read.\n\n### Examples\n```rust\n// Bad\nif { true } { /* ... */ }\n\n// Good\nif true { /* ... */ }\n```\n\n// or\n\n```rust\n// Bad\nif { let x = somefunc(); x } { /* ... */ }\n\n// Good\nlet res = { let x = somefunc(); x };\nif res { /* ... */ }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "bool_assert_comparison",
    "id_span": {
      "path": "src/bool_assert_comparison.rs",
      "line": 26
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns about boolean comparisons in assert-like macros.\n\n### Why is this bad?\nIt is shorter to use the equivalent.\n\n### Example\n```rust\n// Bad\nassert_eq!(\"a\".is_empty(), false);\nassert_ne!(\"a\".is_empty(), true);\n\n// Good\nassert!(!\"a\".is_empty());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "bool_comparison",
    "id_span": {
      "path": "src/needless_bool.rs",
      "line": 68
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for expressions of the form `x == true`,\n`x != true` and order comparisons such as `x < true` (or vice versa) and\nsuggest using the variable directly.\n\n### Why is this bad?\nUnnecessary code.\n\n### Example\n```rust\nif x == true {}\nif y == false {}\n```\nuse `x` directly:\n```rust\nif x {}\nif !y {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "borrow_interior_mutable_const",
    "id_span": {
      "path": "src/non_copy_const.rs",
      "line": 116
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks if `const` items which is interior mutable (e.g.,\ncontains a `Cell`, `Mutex`, `AtomicXxxx`, etc.) has been borrowed directly.\n\n### Why is this bad?\nConsts are copied everywhere they are referenced, i.e.,\nevery time you refer to the const a fresh instance of the `Cell` or `Mutex`\nor `AtomicXxxx` will be created, which defeats the whole purpose of using\nthese types in the first place.\n\nThe `const` value should be stored inside a `static` item.\n\n### Known problems\nWhen an enum has variants with interior mutability, use of its non\ninterior mutable variants can generate false positives. See issue\n[#3962](https://github.com/rust-lang/rust-clippy/issues/3962)\n\nTypes that have underlying or potential interior mutability trigger the lint whether\nthe interior mutable field is used or not. See issues\n[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n[#3825](https://github.com/rust-lang/rust-clippy/issues/3825)\n\n### Example\n```rust\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\n\n// Bad.\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n\n// Good.\nstatic STATIC_ATOM: AtomicUsize = CONST_ATOM;\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "borrowed_box",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 179
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of `&Box<T>` anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n\n### Why is this bad?\nAny `&Box<T>` can also be a `&T`, which is more\ngeneral.\n\n### Example\n```rust\nfn foo(bar: &Box<T>) { ... }\n```\n\nBetter:\n\n```rust\nfn foo(bar: &T) { ... }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "box_collection",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 46
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of `Box<T>` where T is a collection such as Vec anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n\n### Why is this bad?\nCollections already keeps their contents in a separate area on\nthe heap. So if you `Box` them, you just add another level of indirection\nwithout any benefit whatsoever.\n\n### Example\n```rust\nstruct X {\n    values: Box<Vec<Foo>>,\n}\n```\n\nBetter:\n\n```rust\nstruct X {\n    values: Vec<Foo>,\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "boxed_local",
    "id_span": {
      "path": "src/escape.rs",
      "line": 44
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `Box<T>` where an unboxed `T` would\nwork fine.\n\n### Why is this bad?\nThis is an unnecessary allocation, and bad for\nperformance. It is only necessary to allocate if you wish to move the box\ninto something.\n\n### Example\n```rust\n// Bad\nlet x = Box::new(1);\nfoo(*x);\nprintln!(\"{}\", *x);\n\n// Good\nlet x = 1;\nfoo(x);\nprintln!(\"{}\", x);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `too-large-for-stack`: `u64`: The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap (defaults to `200`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "branches_sharing_code",
    "id_span": {
      "path": "src/copies.rs",
      "line": 150
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks if the `if` and `else` block contain shared code that can be\nmoved out of the blocks.\n\n### Why is this bad?\nDuplicate code is less maintainable.\n\n### Known problems\n* The lint doesn't check if the moved expressions modify values that are beeing used in\n  the if condition. The suggestion can in that case modify the behavior of the program.\n  See [rust-clippy#7452](https://github.com/rust-lang/rust-clippy/issues/7452)\n\n### Example\n```rust\nlet foo = if … {\n    println!(\"Hello World\");\n    13\n} else {\n    println!(\"Hello World\");\n    42\n};\n```\n\nCould be written as:\n```rust\nprintln!(\"Hello World\");\nlet foo = if … {\n    13\n} else {\n    42\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "builtin_type_shadow",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 213
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nWarns if a generic shadows a built-in type.\n\n### Why is this bad?\nThis gives surprising type errors.\n\n### Example\n\n```rust\nimpl<u32> Foo<u32> {\n    fn impl_func(&self) -> u32 {\n        42\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "bytes_nth",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1675
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of `.bytes().nth()`.\n\n### Why is this bad?\n`.as_bytes().get()` is more efficient and more\nreadable.\n\n### Example\n```rust\n// Bad\nlet _ = \"Hello\".bytes().nth(3);\n\n// Good\nlet _ = \"Hello\".as_bytes().get(3);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "cargo_common_metadata",
    "id_span": {
      "path": "src/cargo_common_metadata.rs",
      "line": 45
    },
    "group": "cargo",
    "level": "allow",
    "docs": " ### What it does\nChecks to see if all common metadata is defined in\n`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata\n\n### Why is this bad?\nIt will be more difficult for users to discover the\npurpose of the crate, and key information related to it.\n\n### Example\n```toml\n# This `Cargo.toml` is missing a description field:\n[package]\nname = \"clippy\"\nversion = \"0.0.212\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n```\n\nShould include a description field like:\n\n```toml\n# This `Cargo.toml` includes all common metadata\n[package]\nname = \"clippy\"\nversion = \"0.0.212\"\ndescription = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\nrepository = \"https://github.com/rust-lang/rust-clippy\"\nreadme = \"README.md\"\nlicense = \"MIT OR Apache-2.0\"\nkeywords = [\"clippy\", \"lint\", \"plugin\"]\ncategories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "case_sensitive_file_extension_comparisons",
    "id_span": {
      "path": "src/case_sensitive_file_extension_comparisons.rs",
      "line": 30
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for calls to `ends_with` with possible file extensions\nand suggests to use a case-insensitive approach instead.\n\n### Why is this bad?\n`ends_with` is case-sensitive and may not detect files with a valid extension.\n\n### Example\n```rust\nfn is_rust_file(filename: &str) -> bool {\n    filename.ends_with(\".rs\")\n}\n```\nUse instead:\n```rust\nfn is_rust_file(filename: &str) -> bool {\n    filename.rsplit('.').next().map(|ext| ext.eq_ignore_ascii_case(\"rs\")) == Some(true)\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cast_lossless",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 141
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts between numerical types that may\nbe replaced by safe conversion functions.\n\n### Why is this bad?\nRust's `as` keyword will perform many kinds of\nconversions, including silently lossy conversions. Conversion functions such\nas `i32::from` will only perform lossless conversions. Using the conversion\nfunctions prevents conversions from turning into silent lossy conversions if\nthe types of the input expressions ever change, and make it easier for\npeople reading the code to know that the conversion is lossless.\n\n### Example\n```rust\nfn as_u64(x: u8) -> u64 {\n    x as u64\n}\n```\n\nUsing `::from` would look like this:\n\n```rust\nfn as_u64(x: u8) -> u64 {\n    u64::from(x)\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "cast_possible_truncation",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 86
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts between numerical types that may\ntruncate large values. This is expected behavior, so the cast is `Allow` by\ndefault.\n\n### Why is this bad?\nIn some problem domains, it is good practice to avoid\ntruncation. This lint can be activated to help assess where additional\nchecks could be beneficial.\n\n### Example\n```rust\nfn as_u8(x: u64) -> u8 {\n    x as u8\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cast_possible_wrap",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 109
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts from an unsigned type to a signed type of\nthe same size. Performing such a cast is a 'no-op' for the compiler,\ni.e., nothing is changed at the bit level, and the binary representation of\nthe value is reinterpreted. This can cause wrapping if the value is too big\nfor the target signed type. However, the cast works as defined, so this lint\nis `Allow` by default.\n\n### Why is this bad?\nWhile such a cast is not bad in itself, the results can\nbe surprising when this is not the intended behavior, as demonstrated by the\nexample below.\n\n### Example\n```rust\nu32::MAX as i32; // will yield a value of `-1`\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cast_precision_loss",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 43
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts from any numerical to a float type where\nthe receiving type cannot store all values from the original type without\nrounding errors. This possible rounding is to be expected, so this lint is\n`Allow` by default.\n\nBasically, this warns on casting any integer with 32 or more bits to `f32`\nor any 64-bit integer to `f64`.\n\n### Why is this bad?\nIt's not bad at all. But in some applications it can be\nhelpful to know where precision loss can take place. This lint can help find\nthose places in the code.\n\n### Example\n```rust\nlet x = u64::MAX;\nx as f64;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cast_ptr_alignment",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 193
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts, using `as` or `pointer::cast`,\nfrom a less-strictly-aligned pointer to a more-strictly-aligned pointer\n\n### Why is this bad?\nDereferencing the resulting pointer may be undefined\nbehavior.\n\n### Known problems\nUsing `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\non the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\nu64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n\n### Example\n```rust\nlet _ = (&1u8 as *const u8) as *const u16;\nlet _ = (&mut 1u8 as *mut u8) as *mut u16;\n\n(&1u8 as *const u8).cast::<u16>();\n(&mut 1u8 as *mut u8).cast::<u16>();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cast_ref_to_mut",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 320
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for casts of `&T` to `&mut T` anywhere in the code.\n\n### Why is this bad?\nIt’s basically guaranteed to be undefined behaviour.\n`UnsafeCell` is the only way to obtain aliasable data that is considered\nmutable.\n\n### Example\n```rust\nfn x(r: &i32) {\n    unsafe {\n        *(r as *const _ as *mut _) += 1;\n    }\n}\n```\n\nInstead consider using interior mutability types.\n\n```rust\nuse std::cell::UnsafeCell;\n\nfn x(r: &UnsafeCell<i32>) {\n    unsafe {\n        *r.get() += 1;\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cast_sign_loss",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 64
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts from a signed to an unsigned numerical\ntype. In this case, negative values wrap around to large positive values,\nwhich can be quite surprising in practice. However, as the cast works as\ndefined, this lint is `Allow` by default.\n\n### Why is this bad?\nPossibly surprising results. You can activate this lint\nas a one-time check to see where numerical wrapping can arise.\n\n### Example\n```rust\nlet y: i8 = -1;\ny as u128; // will return 18446744073709551615\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "char_lit_as_u8",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 347
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for expressions where a character literal is cast\nto `u8` and suggests using a byte literal instead.\n\n### Why is this bad?\nIn general, casting values to smaller types is\nerror-prone and should be avoided where possible. In the particular case of\nconverting a character literal to u8, it is easy to avoid by just using a\nbyte literal instead. As an added bonus, `b'a'` is even slightly shorter\nthan `'a' as u8`.\n\n### Example\n```rust\n'x' as u8\n```\n\nA better version, using the byte literal:\n\n```rust\nb'x'\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "chars_last_cmp",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1177
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.chars().last()` or\n`_.chars().next_back()` on a `str` to check if it ends with a given char.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.ends_with(_)`.\n\n### Example\n```rust\n\n// Bad\nname.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n\n// Good\nname.ends_with('_') || name.ends_with('-');\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "chars_next_cmp",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 679
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `.chars().next()` on a `str` to check\nif it starts with a given char.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.starts_with(_)`.\n\n### Example\n```rust\nlet name = \"foo\";\nif name.chars().next() == Some('_') {};\n```\nCould be written as\n```rust\nlet name = \"foo\";\nif name.starts_with('_') {};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "checked_conversions",
    "id_span": {
      "path": "src/checked_conversions.rs",
      "line": 39
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for explicit bounds checking when casting.\n\n### Why is this bad?\nReduces the readability of statements & is error prone.\n\n### Example\n```rust\nfoo <= i32::MAX as u32\n```\n\nCould be written:\n\n```rust\ni32::try_from(foo).is_ok()\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "clone_double_ref",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 817
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for usage of `.clone()` on an `&&T`.\n\n### Why is this bad?\nCloning an `&&T` copies the inner `&T`, instead of\ncloning the underlying `T`.\n\n### Example\n```rust\nfn main() {\n    let x = vec![1];\n    let y = &&x;\n    let z = y.clone();\n    println!(\"{:p} {:p}\", *y, z); // prints out the same pointer\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "clone_on_copy",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 768
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `.clone()` on a `Copy` type.\n\n### Why is this bad?\nThe only reason `Copy` types implement `Clone` is for\ngenerics, not for using the `clone` method on a concrete type.\n\n### Example\n```rust\n42u64.clone();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "clone_on_ref_ptr",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 795
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `.clone()` on a ref-counted pointer,\n(`Rc`, `Arc`, `rc::Weak`, or `sync::Weak`), and suggests calling Clone via unified\nfunction syntax instead (e.g., `Rc::clone(foo)`).\n\n### Why is this bad?\nCalling '.clone()' on an Rc, Arc, or Weak\ncan obscure the fact that only the pointer is being cloned, not the underlying\ndata.\n\n### Example\n```rust\nlet x = Rc::new(1);\n\n// Bad\nx.clone();\n\n// Good\nRc::clone(&x);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "cloned_instead_of_copied",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 102
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usages of `cloned()` on an `Iterator` or `Option` where\n`copied()` could be used instead.\n\n### Why is this bad?\n`copied()` is better because it guarantees that the type being cloned\nimplements `Copy`.\n\n### Example\n```rust\n[1, 2, 3].iter().cloned();\n```\nUse instead:\n```rust\n[1, 2, 3].iter().copied();\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "cmp_nan",
    "id_span": {
      "path": "src/misc.rs",
      "line": 82
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for comparisons to NaN.\n\n### Why is this bad?\nNaN does not compare meaningfully to anything – not\neven itself – so those comparisons are simply wrong.\n\n### Example\n```rust\n\n// Bad\nif x == f32::NAN { }\n\n// Good\nif x.is_nan() { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cmp_null",
    "id_span": {
      "path": "src/ptr.rs",
      "line": 99
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint checks for equality comparisons with `ptr::null`\n\n### Why is this bad?\nIt's easier and more readable to use the inherent\n`.is_null()`\nmethod instead\n\n### Example\n```rust\n// Bad\nif x == ptr::null {\n    ..\n}\n\n// Good\nif x.is_null() {\n    ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "cmp_owned",
    "id_span": {
      "path": "src/misc.rs",
      "line": 142
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for conversions to owned values just for the sake\nof a comparison.\n\n### Why is this bad?\nThe comparison can operate on a reference, so creating\nan owned value effectively throws it away directly afterwards, which is\nneedlessly consuming code and heap space.\n\n### Example\n```rust\nif x.to_owned() == y {}\n```\nCould be written as\n```rust\nif x == y {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "cognitive_complexity",
    "id_span": {
      "path": "src/cognitive_complexity.rs",
      "line": 30
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for methods with high cognitive complexity.\n\n### Why is this bad?\nMethods of high cognitive complexity tend to be hard to\nboth read and maintain. Also LLVM will tend to optimize small methods better.\n\n### Known problems\nSometimes it's hard to find a way to reduce the\ncomplexity.\n\n### Example\nNo. You'll see it when you get the warning.\n### Configuration\nThis lint has the following configuration variables:\n\n* `cognitive-complexity-threshold`: `u64`: The maximum cognitive complexity a function can have (defaults to `25`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "collapsible_else_if",
    "id_span": {
      "path": "src/collapsible_if.rs",
      "line": 85
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for collapsible `else { if ... }` expressions\nthat can be collapsed to `else if ...`.\n\n### Why is this bad?\nEach `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is.\n\n### Example\n```rust\n\nif x {\n    …\n} else {\n    if y {\n        …\n    }\n}\n```\n\nShould be written:\n\n```rust.ignore\nif x {\n    …\n} else if y {\n    …\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "collapsible_if",
    "id_span": {
      "path": "src/collapsible_if.rs",
      "line": 50
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for nested `if` statements which can be collapsed\nby `&&`-combining their conditions.\n\n### Why is this bad?\nEach `if`-statement adds one level of nesting, which\nmakes code look more complex than it really is.\n\n### Example\n```rust\nif x {\n    if y {\n        …\n    }\n}\n\n```\n\nShould be written:\n\n```rust.ignore\nif x && y {\n    …\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "collapsible_match",
    "id_span": {
      "path": "src/collapsible_match.rs",
      "line": 44
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nFinds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\nwithout adding any branches.\n\nNote that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\ncases where merging would most likely make the code more readable.\n\n### Why is this bad?\nIt is unnecessarily verbose and complex.\n\n### Example\n```rust\nfn func(opt: Option<Result<u64, String>>) {\n    let n = match opt {\n        Some(n) => match n {\n            Ok(n) => n,\n            _ => return,\n        }\n        None => return,\n    };\n}\n```\nUse instead:\n```rust\nfn func(opt: Option<Result<u64, String>>) {\n    let n = match opt {\n        Some(Ok(n)) => n,\n        _ => return,\n    };\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "comparison_chain",
    "id_span": {
      "path": "src/comparison_chain.rs",
      "line": 52
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks comparison chains written with `if` that can be\nrewritten with `match` and `cmp`.\n\n### Why is this bad?\n`if` is not guaranteed to be exhaustive and conditionals can get\nrepetitive\n\n### Known problems\nThe match statement may be slower due to the compiler\nnot inlining the call to cmp. See issue [#5354](https://github.com/rust-lang/rust-clippy/issues/5354)\n\n### Example\n```rust\nfn f(x: u8, y: u8) {\n    if x > y {\n        a()\n    } else if x < y {\n        b()\n    } else {\n        c()\n    }\n}\n```\n\nCould be written:\n\n```rust\nuse std::cmp::Ordering;\nfn f(x: u8, y: u8) {\n     match x.cmp(&y) {\n         Ordering::Greater => a(),\n         Ordering::Less => b(),\n         Ordering::Equal => c()\n     }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "comparison_to_empty",
    "id_span": {
      "path": "src/len_zero.rs",
      "line": 111
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for comparing to an empty slice such as `\"\"` or `[]`,\nand suggests using `.is_empty()` where applicable.\n\n### Why is this bad?\nSome structures can answer `.is_empty()` much faster\nthan checking for equality. So it is good to get into the habit of using\n`.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts.\n\n### Example\n\n```rust\nif s == \"\" {\n    ..\n}\n\nif arr == [] {\n    ..\n}\n```\nUse instead:\n```rust\nif s.is_empty() {\n    ..\n}\n\nif arr.is_empty() {\n    ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "copy_iterator",
    "id_span": {
      "path": "src/copy_iterator.rs",
      "line": 31
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for types that implement `Copy` as well as\n`Iterator`.\n\n### Why is this bad?\nImplicit copies can be confusing when working with\niterator combinators.\n\n### Example\n```rust\n#[derive(Copy, Clone)]\nstruct Countdown(u8);\n\nimpl Iterator for Countdown {\n    // ...\n}\n\nlet a: Vec<_> = my_iterator.take(1).collect();\nlet b: Vec<_> = my_iterator.collect();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "create_dir",
    "id_span": {
      "path": "src/create_dir.rs",
      "line": 26
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks usage of `std::fs::create_dir` and suggest using `std::fs::create_dir_all` instead.\n\n### Why is this bad?\nSometimes `std::fs::create_dir` is mistakenly chosen over `std::fs::create_dir_all`.\n\n### Example\n\n```rust\nstd::fs::create_dir(\"foo\");\n```\nUse instead:\n```rust\nstd::fs::create_dir_all(\"foo\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "crosspointer_transmute",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 101
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes between a type `T` and `*T`.\n\n### Why is this bad?\nIt's easy to mistakenly transmute between a type and a\npointer to that type.\n\n### Example\n```rust\ncore::intrinsics::transmute(t) // where the result type is the same as\n                               // `*t` or `&t`'s\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "dbg_macro",
    "id_span": {
      "path": "src/dbg_macro.rs",
      "line": 26
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of dbg!() macro.\n\n### Why is this bad?\n`dbg!` macro is intended as a debugging tool. It\nshould not be in version control.\n\n### Example\n```rust\n// Bad\ndbg!(true)\n\n// Good\ntrue\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "debug_assert_with_mut_call",
    "id_span": {
      "path": "src/mutable_debug_assertion.rs",
      "line": 29
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for function/method calls with a mutable\nparameter in `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!` macros.\n\n### Why is this bad?\nIn release builds `debug_assert!` macros are optimized out by the\ncompiler.\nTherefore mutating something in a `debug_assert!` macro results in different behaviour\nbetween a release and debug build.\n\n### Example\n```rust\ndebug_assert_eq!(vec![3].pop(), Some(3));\n// or\nfn take_a_mut_parameter(_: &mut u32) -> bool { unimplemented!() }\ndebug_assert!(take_a_mut_parameter(&mut 5));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "decimal_literal_representation",
    "id_span": {
      "path": "src/literal_representation.rs",
      "line": 134
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nWarns if there is a better representation for a numeric literal.\n\n### Why is this bad?\nEspecially for big powers of 2 a hexadecimal representation is more\nreadable than a decimal representation.\n\n### Example\n`255` => `0xFF`\n`65_535` => `0xFFFF`\n`4_042_322_160` => `0xF0F0_F0F0`\n### Configuration\nThis lint has the following configuration variables:\n\n* `literal-representation-threshold`: `u64`: The lower bound for linting decimal literals (defaults to `16384`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "declare_interior_mutable_const",
    "id_span": {
      "path": "src/non_copy_const.rs",
      "line": 72
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for declaration of `const` items which is interior\nmutable (e.g., contains a `Cell`, `Mutex`, `AtomicXxxx`, etc.).\n\n### Why is this bad?\nConsts are copied everywhere they are referenced, i.e.,\nevery time you refer to the const a fresh instance of the `Cell` or `Mutex`\nor `AtomicXxxx` will be created, which defeats the whole purpose of using\nthese types in the first place.\n\nThe `const` should better be replaced by a `static` item if a global\nvariable is wanted, or replaced by a `const fn` if a constructor is wanted.\n\n### Known problems\nA \"non-constant\" const item is a legacy way to supply an\ninitialized value to downstream `static` items (e.g., the\n`std::sync::ONCE_INIT` constant). In this case the use of `const` is legit,\nand this lint should be suppressed.\n\nEven though the lint avoids triggering on a constant whose type has enums that have variants\nwith interior mutability, and its value uses non interior mutable variants (see\n[#3962](https://github.com/rust-lang/rust-clippy/issues/3962) and\n[#3825](https://github.com/rust-lang/rust-clippy/issues/3825) for examples);\nit complains about associated constants without default values only based on its types;\nwhich might not be preferable.\nThere're other enums plus associated constants cases that the lint cannot handle.\n\nTypes that have underlying or potential interior mutability trigger the lint whether\nthe interior mutable field is used or not. See issues\n[#5812](https://github.com/rust-lang/rust-clippy/issues/5812) and\n\n### Example\n```rust\nuse std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n\n// Bad.\nconst CONST_ATOM: AtomicUsize = AtomicUsize::new(12);\nCONST_ATOM.store(6, SeqCst); // the content of the atomic is unchanged\nassert_eq!(CONST_ATOM.load(SeqCst), 12); // because the CONST_ATOM in these lines are distinct\n\n// Good.\nstatic STATIC_ATOM: AtomicUsize = AtomicUsize::new(15);\nSTATIC_ATOM.store(9, SeqCst);\nassert_eq!(STATIC_ATOM.load(SeqCst), 9); // use a `static` item to refer to the same instance\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "default_numeric_fallback",
    "id_span": {
      "path": "src/default_numeric_fallback.rs",
      "line": 49
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of unconstrained numeric literals which may cause default numeric fallback in type\ninference.\n\nDefault numeric fallback means that if numeric types have not yet been bound to concrete\ntypes at the end of type inference, then integer type is bound to `i32`, and similarly\nfloating type is bound to `f64`.\n\nSee [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n\n### Why is this bad?\nFor those who are very careful about types, default numeric fallback\ncan be a pitfall that cause unexpected runtime behavior.\n\n### Known problems\nThis lint can only be allowed at the function level or above.\n\n### Example\n```rust\nlet i = 10;\nlet f = 1.23;\n```\n\nUse instead:\n```rust\nlet i = 10i32;\nlet f = 1.23f64;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "default_trait_access",
    "id_span": {
      "path": "src/default.rs",
      "line": 32
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for literal calls to `Default::default()`.\n\n### Why is this bad?\nIt's more clear to the reader to use the name of the type whose default is\nbeing gotten than the generic `Default`.\n\n### Example\n```rust\n// Bad\nlet s: String = Default::default();\n\n// Good\nlet s = String::default();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "deprecated_cfg_attr",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 211
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\nwith `#[rustfmt::skip]`.\n\n### Why is this bad?\nSince tool_attributes ([rust-lang/rust#44690](https://github.com/rust-lang/rust/issues/44690))\nare stable now, they should be used instead of the old `cfg_attr(rustfmt)` attributes.\n\n### Known problems\nThis lint doesn't detect crate level inner attributes, because they get\nprocessed before the PreExpansionPass lints get executed. See\n[#3123](https://github.com/rust-lang/rust-clippy/pull/3123#issuecomment-422321765)\n\n### Example\nBad:\n```rust\n#[cfg_attr(rustfmt, rustfmt_skip)]\nfn main() { }\n```\n\nGood:\n```rust\n#[rustfmt::skip]\nfn main() { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "deprecated_semver",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 120
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `#[deprecated]` annotations with a `since`\nfield that is not a valid semantic version.\n\n### Why is this bad?\nFor checking the version of the deprecation, it must be\na valid semver. Failing that, the contained information is useless.\n\n### Example\n```rust\n#[deprecated(since = \"forever\")]\nfn something_else() { /* ... */ }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "deref_addrof",
    "id_span": {
      "path": "src/reference.rs",
      "line": 34
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `*&` and `*&mut` in expressions.\n\n### Why is this bad?\nImmediately dereferencing a reference is no-op and\nmakes the code less clear.\n\n### Known problems\nMultiple dereference/addrof pairs are not handled so\nthe suggested fix for `x = **&&y` is `x = *&y`, which is still incorrect.\n\n### Example\n```rust\n// Bad\nlet a = f(*&mut b);\nlet c = *&d;\n\n// Good\nlet a = f(b);\nlet c = d;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "derivable_impls",
    "id_span": {
      "path": "src/derivable_impls.rs",
      "line": 49
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nDetects manual `std::default::Default` implementations that are identical to a derived implementation.\n\n### Why is this bad?\nIt is less concise.\n\n### Example\n```rust\nstruct Foo {\n    bar: bool\n}\n\nimpl std::default::Default for Foo {\n    fn default() -> Self {\n        Self {\n            bar: false\n        }\n    }\n}\n```\n\nCould be written as:\n\n```rust\n#[derive(Default)]\nstruct Foo {\n    bar: bool\n}\n```\n\n### Known problems\nDerive macros [sometimes use incorrect bounds](https://github.com/rust-lang/rust/issues/26925)\nin generic types and the user defined `impl` maybe is more generalized or\nspecialized than what derive will produce. This lint can't detect the manual `impl`\nhas exactly equal bounds, and therefore this lint is disabled for types with\ngeneric parameters.\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "derive_hash_xor_eq",
    "id_span": {
      "path": "src/derive.rs",
      "line": 41
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for deriving `Hash` but implementing `PartialEq`\nexplicitly or vice versa.\n\n### Why is this bad?\nThe implementation of these traits must agree (for\nexample for use with `HashMap`) so it’s probably a bad idea to use a\ndefault-generated `Hash` implementation with an explicitly defined\n`PartialEq`. In particular, the following must hold for any type:\n\n```text\nk1 == k2 ⇒ hash(k1) == hash(k2)\n```\n\n### Example\n```rust\n#[derive(Hash)]\nstruct Foo;\n\nimpl PartialEq for Foo {\n    ...\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "derive_ord_xor_partial_ord",
    "id_span": {
      "path": "src/derive.rs",
      "line": 91
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for deriving `Ord` but implementing `PartialOrd`\nexplicitly or vice versa.\n\n### Why is this bad?\nThe implementation of these traits must agree (for\nexample for use with `sort`) so it’s probably a bad idea to use a\ndefault-generated `Ord` implementation with an explicitly defined\n`PartialOrd`. In particular, the following must hold for any type\nimplementing `Ord`:\n\n```text\nk1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n```\n\n### Example\n```rust\n#[derive(Ord, PartialEq, Eq)]\nstruct Foo;\n\nimpl PartialOrd for Foo {\n    ...\n}\n```\nUse instead:\n```rust\n#[derive(PartialEq, Eq)]\nstruct Foo;\n\nimpl PartialOrd for Foo {\n    fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n       Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Foo {\n    ...\n}\n```\nor, if you don't need a custom ordering:\n```rust\n#[derive(Ord, PartialOrd, PartialEq, Eq)]\nstruct Foo;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "disallowed_method",
    "id_span": {
      "path": "src/disallowed_method.rs",
      "line": 50
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nDenies the configured methods and functions in clippy.toml\n\n### Why is this bad?\nSome methods are undesirable in certain contexts, and it's beneficial to\nlint for them as needed.\n\n### Example\nAn example clippy.toml configuration:\n```toml\n# clippy.toml\ndisallowed-methods = [\n    # Can use a string as the path of the disallowed method.\n    \"std::boxed::Box::new\",\n    # Can also use an inline table with a `path` key.\n    { path = \"std::time::Instant::now\" },\n    # When using an inline table, can add a `reason` for why the method\n    # is disallowed.\n    { path = \"std::vec::Vec::leak\", reason = \"no leaking memory\" },\n]\n```\n\n```rust\n// Example code where clippy issues a warning\nlet xs = vec![1, 2, 3, 4];\nxs.leak(); // Vec::leak is disallowed in the config.\n// The diagnostic contains the message \"no leaking memory\".\n\nlet _now = Instant::now(); // Instant::now is disallowed in the config.\n\nlet _box = Box::new(3); // Box::new is disallowed in the config.\n```\n\nUse instead:\n```rust\n// Example code which does not raise clippy warning\nlet mut xs = Vec::new(); // Vec::new is _not_ disallowed in the config.\nxs.push(123); // Vec::push is _not_ disallowed in the config.\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `disallowed-methods`: `Vec<crate::utils::conf::DisallowedMethod>`: The list of disallowed methods, written as fully qualified paths. (defaults to `[]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "disallowed_script_idents",
    "id_span": {
      "path": "src/disallowed_script_idents.rs",
      "line": 41
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of unicode scripts other than those explicitly allowed\nby the lint config.\n\nThis lint doesn't take into account non-text scripts such as `Unknown` and `Linear_A`.\nIt also ignores the `Common` script type.\nWhile configuring, be sure to use official script name [aliases] from\n[the list of supported scripts][supported_scripts].\n\nSee also: [`non_ascii_idents`].\n\n[aliases]: http://www.unicode.org/reports/tr24/tr24-31.html#Script_Value_Aliases\n[supported_scripts]: https://www.unicode.org/iso15924/iso15924-codes.html\n\n### Why is this bad?\nIt may be not desired to have many different scripts for\nidentifiers in the codebase.\n\nNote that if you only want to allow plain English, you might want to use\nbuilt-in [`non_ascii_idents`] lint instead.\n\n[`non_ascii_idents`]: https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html#non-ascii-idents\n\n### Example\n```rust\n// Assuming that `clippy.toml` contains the following line:\n// allowed-locales = [\"Latin\", \"Cyrillic\"]\nlet counter = 10; // OK, latin is allowed.\nlet счётчик = 10; // OK, cyrillic is allowed.\nlet zähler = 10; // OK, it's still latin.\nlet カウンタ = 10; // Will spawn the lint.\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `allowed-scripts`: `Vec<String>`: The list of unicode scripts allowed to be used in the scope. (defaults to `[\"Latin\"]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "disallowed_type",
    "id_span": {
      "path": "src/disallowed_type.rs",
      "line": 45
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nDenies the configured types in clippy.toml.\n\n### Why is this bad?\nSome types are undesirable in certain contexts.\n\n### Example:\nAn example clippy.toml configuration:\n```toml\n# clippy.toml\ndisallowed-types = [\n    # Can use a string as the path of the disallowed type.\n    \"std::collections::BTreeMap\",\n    # Can also use an inline table with a `path` key.\n    { path = \"std::net::TcpListener\" },\n    # When using an inline table, can add a `reason` for why the type\n    # is disallowed.\n    { path = \"std::net::Ipv4Addr\", reason = \"no IPv4 allowed\" },\n]\n```\n\n```rust\nuse std::collections::BTreeMap;\n// or its use\nlet x = std::collections::BTreeMap::new();\n```\nUse instead:\n```rust\n// A similar type that is allowed by the config\nuse std::collections::HashMap;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `disallowed-types`: `Vec<crate::utils::conf::DisallowedType>`: The list of disallowed types, written as fully qualified paths. (defaults to `[]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "diverging_sub_expression",
    "id_span": {
      "path": "src/eval_order_dependence.rs",
      "line": 70
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for diverging calls that are not match arms or\nstatements.\n\n### Why is this bad?\nIt is often confusing to read. In addition, the\nsub-expression evaluation order for Rust is not well documented.\n\n### Known problems\nSomeone might want to use `some_bool || panic!()` as a\nshorthand.\n\n### Example\n```rust\nlet a = b() || panic!() || c();\n// `c()` is dead, `panic!()` is only called if `b()` returns `false`\nlet x = (a, b, c, panic!());\n// can simply be replaced by `panic!()`\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "doc_markdown",
    "id_span": {
      "path": "src/doc.rs",
      "line": 70
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for the presence of `_`, `::` or camel-case words\noutside ticks in documentation.\n\n### Why is this bad?\n*Rustdoc* supports markdown formatting, `_`, `::` and\ncamel-case probably indicates some code which should be included between\nticks. `_` can also be used for emphasis in markdown, this lint tries to\nconsider that.\n\n### Known problems\nLots of bad docs won’t be fixed, what the lint checks\nfor is limited, and there are still false positives. HTML elements and their\ncontent are not linted.\n\nIn addition, when writing documentation comments, including `[]` brackets\ninside a link text would trip the parser. Therefore, documenting link with\n`[`SmallVec<[T; INLINE_CAPACITY]>`]` and then [`SmallVec<[T; INLINE_CAPACITY]>`]: SmallVec\nwould fail.\n\n### Examples\n```rust\n/// Do something with the foo_bar parameter. See also\n/// that::other::module::foo.\n// ^ `foo_bar` and `that::other::module::foo` should be ticked.\nfn doit(foo_bar: usize) {}\n```\n\n```rust\n// Link text with `[]` brackets should be written as following:\n/// Consume the array and return the inner\n/// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n/// [SmallVec]: SmallVec\nfn main() {}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `doc-valid-idents`: `Vec<String>`: The list of words this lint should not consider as identifiers needing ticks (defaults to `[\"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"DirectX\", \"ECMAScript\", \"GPLv2\", \"GPLv3\", \"GitHub\", \"GitLab\", \"IPv4\", \"IPv6\", \"ClojureScript\", \"CoffeeScript\", \"JavaScript\", \"PureScript\", \"TypeScript\", \"NaN\", \"NaNs\", \"OAuth\", \"GraphQL\", \"OCaml\", \"OpenGL\", \"OpenMP\", \"OpenSSH\", \"OpenSSL\", \"OpenStreetMap\", \"OpenDNS\", \"WebGL\", \"TensorFlow\", \"TrueType\", \"iOS\", \"macOS\", \"FreeBSD\", \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\", \"MinGW\", \"CamelCase\"]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "double_comparisons",
    "id_span": {
      "path": "src/double_comparison.rs",
      "line": 34
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for double comparisons that could be simplified to a single expression.\n\n\n### Why is this bad?\nReadability.\n\n### Example\n```rust\nif x == y || x < y {}\n```\n\nCould be written as:\n\n```rust\nif x <= y {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "double_must_use",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 129
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for a `#[must_use]` attribute without\nfurther information on functions and methods that return a type already\nmarked as `#[must_use]`.\n\n### Why is this bad?\nThe attribute isn't needed. Not using the result\nwill already be reported. Alternatively, one can add some text to the\nattribute to improve the lint message.\n\n### Examples\n```rust\n#[must_use]\nfn double_must_use() -> Result<(), ()> {\n    unimplemented!();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "double_neg",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 88
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nDetects expressions of the form `--x`.\n\n### Why is this bad?\nIt can mislead C/C++ programmers to think `x` was\ndecremented.\n\n### Example\n```rust\nlet mut x = 3;\n--x;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "double_parens",
    "id_span": {
      "path": "src/double_parens.rs",
      "line": 35
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for unnecessary double parentheses.\n\n### Why is this bad?\nThis makes code harder to read and might indicate a\nmistake.\n\n### Example\n```rust\n// Bad\nfn simple_double_parens() -> i32 {\n    ((0))\n}\n\n// Good\nfn simple_no_parens() -> i32 {\n    0\n}\n\n// or\n\n// Bad\nfoo((0));\n\n// Good\nfoo(0);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "drop_copy",
    "id_span": {
      "path": "src/drop_forget_ref.rs",
      "line": 70
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calls to `std::mem::drop` with a value\nthat derives the Copy trait\n\n### Why is this bad?\nCalling `std::mem::drop` [does nothing for types that\nimplement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html), since the\nvalue will be copied and moved into the function on invocation.\n\n### Example\n```rust\nlet x: i32 = 42; // i32 implements Copy\nstd::mem::drop(x) // A copy of x is passed to the function, leaving the\n                  // original unaffected\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "drop_ref",
    "id_span": {
      "path": "src/drop_forget_ref.rs",
      "line": 28
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calls to `std::mem::drop` with a reference\ninstead of an owned value.\n\n### Why is this bad?\nCalling `drop` on a reference will only drop the\nreference itself, which is a no-op. It will not call the `drop` method (from\nthe `Drop` trait implementation) on the underlying referenced value, which\nis likely what was intended.\n\n### Example\n```rust\nlet mut lock_guard = mutex.lock();\nstd::mem::drop(&lock_guard) // Should have been drop(lock_guard), mutex\n// still locked\noperation_that_requires_mutex_to_be_unlocked();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "duplicate_underscore_argument",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 70
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for function arguments having the similar names\ndiffering by an underscore.\n\n### Why is this bad?\nIt affects code readability.\n\n### Example\n```rust\n// Bad\nfn foo(a: i32, _a: i32) {}\n\n// Good\nfn bar(a: i32, _b: i32) {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "duration_subsec",
    "id_span": {
      "path": "src/duration_subsec.rs",
      "line": 36
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for calculation of subsecond microseconds or milliseconds\nfrom other `Duration` methods.\n\n### Why is this bad?\nIt's more concise to call `Duration::subsec_micros()` or\n`Duration::subsec_millis()` than to calculate them.\n\n### Example\n```rust\nlet dur = Duration::new(5, 0);\n\n// Bad\nlet _micros = dur.subsec_nanos() / 1_000;\nlet _millis = dur.subsec_nanos() / 1_000_000;\n\n// Good\nlet _micros = dur.subsec_micros();\nlet _millis = dur.subsec_millis();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "else_if_without_else",
    "id_span": {
      "path": "src/else_if_without_else.rs",
      "line": 43
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of if expressions with an `else if` branch,\nbut without a final `else` branch.\n\n### Why is this bad?\nSome coding guidelines require this (e.g., MISRA-C:2004 Rule 14.10).\n\n### Example\n```rust\nif x.is_positive() {\n    a();\n} else if x.is_negative() {\n    b();\n}\n```\n\nCould be written:\n\n```rust\nif x.is_positive() {\n    a();\n} else if x.is_negative() {\n    b();\n} else {\n    // We don't care about zero.\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "empty_enum",
    "id_span": {
      "path": "src/empty_enum.rs",
      "line": 37
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `enum`s with no variants.\n\nAs of this writing, the `never_type` is still a\nnightly-only experimental API. Therefore, this lint is only triggered\nif the `never_type` is enabled.\n\n### Why is this bad?\nIf you want to introduce a type which\ncan't be instantiated, you should use `!` (the primitive type \"never\"),\nor a wrapper around it, because `!` has more extensive\ncompiler support (type inference, etc...) and wrappers\naround it are the conventional way to define an uninhabited type.\nFor further information visit [never type documentation](https://doc.rust-lang.org/std/primitive.never.html)\n\n\n### Example\nBad:\n```rust\nenum Test {}\n```\n\nGood:\n```rust\n#![feature(never_type)]\n\nstruct Test(!);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "empty_line_after_outer_attr",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 157
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for empty lines after outer attributes\n\n### Why is this bad?\nMost likely the attribute was meant to be an inner attribute using a '!'.\nIf it was meant to be an outer attribute, then the following item\nshould not be separated by empty lines.\n\n### Known problems\nCan cause false positives.\n\nFrom the clippy side it's difficult to detect empty lines between an attributes and the\nfollowing item because empty lines and comments are not part of the AST. The parsing\ncurrently works for basic cases but is not perfect.\n\n### Example\n```rust\n// Good (as inner attribute)\n#![allow(dead_code)]\n\nfn this_is_fine() { }\n\n// Bad\n#[allow(dead_code)]\n\nfn not_quite_good_code() { }\n\n// Good (as outer attribute)\n#[allow(dead_code)]\nfn this_is_fine_too() { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "empty_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 320
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for empty `loop` expressions.\n\n### Why is this bad?\nThese busy loops burn CPU cycles without doing\nanything. It is _almost always_ a better idea to `panic!` than to have\na busy loop.\n\nIf panicking isn't possible, think of the environment and either:\n  - block on something\n  - sleep the thread for some microseconds\n  - yield or pause the thread\n\nFor `std` targets, this can be done with\n[`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\nor [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n\nFor `no_std` targets, doing this is more complicated, especially because\n`#[panic_handler]`s can't panic. To stop/pause the thread, you will\nprobably need to invoke some target-specific intrinsic. Examples include:\n  - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n  - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n\n### Example\n```rust\nloop {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "enum_clike_unportable_variant",
    "id_span": {
      "path": "src/enum_clike.rs",
      "line": 31
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for C-like enumerations that are\n`repr(isize/usize)` and have values that don't fit into an `i32`.\n\n### Why is this bad?\nThis will truncate the variant value on 32 bit\narchitectures, but works fine on 64 bit.\n\n### Example\n```rust\n#[repr(usize)]\nenum NonPortable {\n    X = 0x1_0000_0000,\n    Y = 0,\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "enum_glob_use",
    "id_span": {
      "path": "src/wildcard_imports.rs",
      "line": 37
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `use Enum::*`.\n\n### Why is this bad?\nIt is usually better style to use the prefixed name of\nan enumeration variant, rather than importing variants.\n\n### Known problems\nOld-style enumerations that prefix the variants are\nstill around.\n\n### Example\n```rust\n// Bad\nuse std::cmp::Ordering::*;\nfoo(Less);\n\n// Good\nuse std::cmp::Ordering;\nfoo(Ordering::Less)\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "enum_variant_names",
    "id_span": {
      "path": "src/enum_variants.rs",
      "line": 37
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nDetects enumeration variants that are prefixed or suffixed\nby the same characters.\n\n### Why is this bad?\nEnumeration variant names should specify their variant,\nnot repeat the enumeration name.\n\n### Example\n```rust\nenum Cake {\n    BlackForestCake,\n    HummingbirdCake,\n    BattenbergCake,\n}\n```\nCould be written as:\n```rust\nenum Cake {\n    BlackForest,\n    Hummingbird,\n    Battenberg,\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n* `enum-variant-name-threshold`: `u64`: The minimum number of enum variants for the lints about variant names to trigger (defaults to `3`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "eq_op",
    "id_span": {
      "path": "src/eq_op.rs",
      "line": 39
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for equal operands to comparison, logical and\nbitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n`||`, `&`, `|`, `^`, `-` and `/`).\n\n### Why is this bad?\nThis is usually just a typo or a copy and paste error.\n\n### Known problems\nFalse negatives: We had some false positives regarding\ncalls (notably [racer](https://github.com/phildawes/racer) had one instance\nof `x.pop() && x.pop()`), so we removed matching any function or method\ncalls. We may introduce a list of known pure functions in the future.\n\n### Example\n```rust\nif x + 1 == x + 1 {}\n```\nor\n```rust\nassert_eq!(a, a);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "equatable_if_let",
    "id_span": {
      "path": "src/equatable_if_let.rs",
      "line": 35
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for pattern matchings that can be expressed using equality.\n\n### Why is this bad?\n\n* It reads better and has less cognitive load because equality won't cause binding.\n* It is a [Yoda condition](https://en.wikipedia.org/wiki/Yoda_conditions). Yoda conditions are widely\ncriticized for increasing the cognitive load of reading the code.\n* Equality is a simple bool expression and can be merged with `&&` and `||` and\nreuse if blocks\n\n### Example\n```rust\nif let Some(2) = x {\n    do_thing();\n}\n```\nShould be written\n```rust\nif x == Some(2) {\n    do_thing();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "erasing_op",
    "id_span": {
      "path": "src/erasing_op.rs",
      "line": 24
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for erasing operations, e.g., `x * 0`.\n\n### Why is this bad?\nThe whole expression can be replaced by zero.\nThis is most likely not the intended outcome and should probably be\ncorrected\n\n### Example\n```rust\nlet x = 1;\n0 / x;\n0 * x;\nx & 0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "eval_order_dependence",
    "id_span": {
      "path": "src/eval_order_dependence.rs",
      "line": 43
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for a read and a write to the same variable where\nwhether the read occurs before or after the write depends on the evaluation\norder of sub-expressions.\n\n### Why is this bad?\nIt is often confusing to read. As described [here](https://doc.rust-lang.org/reference/expressions.html?highlight=subexpression#evaluation-order-of-operands),\nthe operands of these expressions are evaluated before applying the effects of the expression.\n\n### Known problems\nCode which intentionally depends on the evaluation\norder, or which is correct for any evaluation order.\n\n### Example\n```rust\nlet mut x = 0;\n\n// Bad\nlet a = {\n    x = 1;\n    1\n} + x;\n// Unclear whether a is 1 or 2.\n\n// Good\nlet tmp = {\n    x = 1;\n    1\n};\nlet a = tmp + x;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "excessive_precision",
    "id_span": {
      "path": "src/float_literal.rs",
      "line": 30
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for float literals with a precision greater\nthan that supported by the underlying type.\n\n### Why is this bad?\nRust will truncate the literal silently.\n\n### Example\n```rust\n// Bad\nlet v: f32 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789\n\n// Good\nlet v: f64 = 0.123_456_789_9;\nprintln!(\"{}\", v); //  0.123_456_789_9\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "exhaustive_enums",
    "id_span": {
      "path": "src/exhaustive_items.rs",
      "line": 34
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nWarns on any exported `enum`s that are not tagged `#[non_exhaustive]`\n\n### Why is this bad?\nExhaustive enums are typically fine, but a project which does\nnot wish to make a stability commitment around exported enums may wish to\ndisable them by default.\n\n### Example\n```rust\nenum Foo {\n    Bar,\n    Baz\n}\n```\nUse instead:\n```rust\n#[non_exhaustive]\nenum Foo {\n    Bar,\n    Baz\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "exhaustive_structs",
    "id_span": {
      "path": "src/exhaustive_items.rs",
      "line": 63
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nWarns on any exported `structs`s that are not tagged `#[non_exhaustive]`\n\n### Why is this bad?\nExhaustive structs are typically fine, but a project which does\nnot wish to make a stability commitment around exported structs may wish to\ndisable them by default.\n\n### Example\n```rust\nstruct Foo {\n    bar: u8,\n    baz: String,\n}\n```\nUse instead:\n```rust\n#[non_exhaustive]\nstruct Foo {\n    bar: u8,\n    baz: String,\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "exit",
    "id_span": {
      "path": "src/exit.rs",
      "line": 21
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\n`exit()`  terminates the program and doesn't provide a\nstack trace.\n\n### Why is this bad?\nIdeally a program is terminated by finishing\nthe main function.\n\n### Example\n```rust\nstd::process::exit(0)\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "expect_fun_call",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 751
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\netc., and suggests to use `unwrap_or_else` instead\n\n### Why is this bad?\nThe function will always be called.\n\n### Known problems\nIf the function has side-effects, not calling it will\nchange the semantics of the program, but you shouldn't rely on that anyway.\n\n### Example\n```rust\nfoo.expect(&format!(\"Err {}: {}\", err_code, err_msg));\n```\nor\n```rust\nfoo.expect(format!(\"Err {}: {}\", err_code, err_msg).as_str());\n```\nthis can instead be written:\n```rust\nfoo.unwrap_or_else(|| panic!(\"Err {}: {}\", err_code, err_msg));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "expect_used",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 211
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `.expect()` calls on `Option`s and `Result`s.\n\n### Why is this bad?\nUsually it is better to handle the `None` or `Err` case.\nStill, for a lot of quick-and-dirty code, `expect` is a good choice, which is why\nthis lint is `Allow` by default.\n\n`result.expect()` will let the thread panic on `Err`\nvalues. Normally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `?` operator.\n\n### Examples\n```rust\n\n// Bad\nopt.expect(\"one\");\n\n// Good\nlet opt = Some(1);\nopt?;\n```\n\n// or\n\n```rust\n\n// Bad\nres.expect(\"one\");\n\n// Good\nres?;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "expl_impl_clone_on_copy",
    "id_span": {
      "path": "src/derive.rs",
      "line": 117
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for explicit `Clone` implementations for `Copy`\ntypes.\n\n### Why is this bad?\nTo avoid surprising behaviour, these traits should\nagree and the behaviour of `Copy` cannot be overridden. In almost all\nsituations a `Copy` type should have a `Clone` implementation that does\nnothing more than copy the object, which is what `#[derive(Copy, Clone)]`\ngets you.\n\n### Example\n```rust\n#[derive(Copy)]\nstruct Foo;\n\nimpl Clone for Foo {\n    // ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "explicit_counter_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 287
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks `for` loops over slices with an explicit counter\nand suggests the use of `.enumerate()`.\n\n### Why is this bad?\nUsing `.enumerate()` makes the intent more clear,\ndeclutters the code and may be faster in some instances.\n\n### Example\n```rust\nlet mut i = 0;\nfor item in &v {\n    bar(i, *item);\n    i += 1;\n}\n```\nCould be written as\n```rust\nfor (i, item) in v.iter().enumerate() { bar(i, *item); }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "explicit_deref_methods",
    "id_span": {
      "path": "src/dereference.rs",
      "line": 37
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for explicit `deref()` or `deref_mut()` method calls.\n\n### Why is this bad?\nDereferencing by `&*x` or `&mut *x` is clearer and more concise,\nwhen not part of a method chain.\n\n### Example\n```rust\nuse std::ops::Deref;\nlet a: &mut String = &mut String::from(\"foo\");\nlet b: &str = a.deref();\n```\nCould be written as:\n```rust\nlet a: &mut String = &mut String::from(\"foo\");\nlet b = &*a;\n```\n\nThis lint excludes\n```rust\nlet _ = d.unwrap().deref();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "explicit_into_iter_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 138
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for loops on `y.into_iter()` where `y` will do, and\nsuggests the latter.\n\n### Why is this bad?\nReadability.\n\n### Example\n```rust\n// with `y` a `Vec` or slice:\nfor x in y.into_iter() {\n    // ..\n}\n```\ncan be rewritten to\n```rust\nfor x in y {\n    // ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "explicit_iter_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 110
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for loops on `x.iter()` where `&x` will do, and\nsuggests the latter.\n\n### Why is this bad?\nReadability.\n\n### Known problems\nFalse negatives. We currently only warn on some known\ntypes.\n\n### Example\n```rust\n// with `y` a `Vec` or slice:\nfor x in y.iter() {\n    // ..\n}\n```\ncan be rewritten to\n```rust\nfor x in &y {\n    // ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "explicit_write",
    "id_span": {
      "path": "src/explicit_write.rs",
      "line": 26
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `write!()` / `writeln()!` which can be\nreplaced with `(e)print!()` / `(e)println!()`\n\n### Why is this bad?\nUsing `(e)println! is clearer and more concise\n\n### Example\n```rust\n// this would be clearer as `eprintln!(\"foo: {:?}\", bar);`\nwriteln!(&mut std::io::stderr(), \"foo: {:?}\", bar).unwrap();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "extend_from_slice",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 35
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis used to check for `Vec::extend`, which was slower than\n`Vec::extend_from_slice`. Thanks to specialization, this is no longer true.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "extend_with_drain",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1101
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for occurrences where one vector gets extended instead of append\n\n### Why is this bad?\nUsing `append` instead of `extend` is more concise and faster\n\n### Example\n```rust\nlet mut a = vec![1, 2, 3];\nlet mut b = vec![4, 5, 6];\n\n// Bad\na.extend(b.drain(..));\n\n// Good\na.append(&mut b);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "extra_unused_lifetimes",
    "id_span": {
      "path": "src/lifetimes.rs",
      "line": 76
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for lifetimes in generics that are never used\nanywhere else.\n\n### Why is this bad?\nThe additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.\n\n### Example\n```rust\n// Bad: unnecessary lifetimes\nfn unused_lifetime<'a>(x: u8) {\n    // ..\n}\n\n// Good\nfn no_lifetime(x: u8) {\n    // ...\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "fallible_impl_from",
    "id_span": {
      "path": "src/fallible_impl_from.rs",
      "line": 47
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for impls of `From<..>` that contain `panic!()` or `unwrap()`\n\n### Why is this bad?\n`TryFrom` should be used if there's a possibility of failure.\n\n### Example\n```rust\nstruct Foo(i32);\n\n// Bad\nimpl From<String> for Foo {\n    fn from(s: String) -> Self {\n        Foo(s.parse().unwrap())\n    }\n}\n```\n\n```rust\n// Good\nstruct Foo(i32);\n\nuse std::convert::TryFrom;\nimpl TryFrom<String> for Foo {\n    type Error = ();\n    fn try_from(s: String) -> Result<Self, Self::Error> {\n        if let Ok(parsed) = s.parse() {\n            Ok(Foo(parsed))\n        } else {\n            Err(())\n        }\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "field_reassign_with_default",
    "id_span": {
      "path": "src/default.rs",
      "line": 65
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for immediate reassignment of fields initialized\nwith Default::default().\n\n### Why is this bad?\nIt's more idiomatic to use the [functional update syntax](https://doc.rust-lang.org/reference/expressions/struct-expr.html#functional-update-syntax).\n\n### Known problems\nAssignments to patterns that are of tuple type are not linted.\n\n### Example\nBad:\n```rust\nlet mut a: A = Default::default();\na.i = 42;\n```\nUse instead:\n```rust\nlet a = A {\n    i: 42,\n    .. Default::default()\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "filetype_is_file",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1415
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `FileType::is_file()`.\n\n### Why is this bad?\nWhen people testing a file type with `FileType::is_file`\nthey are testing whether a path is something they can get bytes from. But\n`is_file` doesn't cover special file types in unix-like systems, and doesn't cover\nsymlink in windows. Using `!FileType::is_dir()` is a better way to that intention.\n\n### Example\n```rust\nlet metadata = std::fs::metadata(\"foo.txt\")?;\nlet filetype = metadata.file_type();\n\nif filetype.is_file() {\n    // read file\n}\n```\n\nshould be written as:\n\n```rust\nlet metadata = std::fs::metadata(\"foo.txt\")?;\nlet filetype = metadata.file_type();\n\nif !filetype.is_dir() {\n    // read file\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "filter_map",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 172
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis lint has been replaced by `manual_filter_map`, a\nmore specific lint.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "filter_map_identity",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1632
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `filter_map(|x| x)`.\n\n### Why is this bad?\nReadability, this can be written more concisely by using `flatten`.\n\n### Example\n```rust\niter.filter_map(|x| x);\n```\nUse instead:\n```rust\niter.flatten();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "filter_map_next",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 604
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `_.filter_map(_).next()`.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.find_map(_)`.\n\n### Example\n```rust\n (0..3).filter_map(|x| if x == 2 { Some(x) } else { None }).next();\n```\nCan be written as\n\n```rust\n (0..3).find_map(|x| if x == 2 { Some(x) } else { None });\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "filter_next",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 484
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.filter(_).next()`.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.find(_)`.\n\n### Example\n```rust\nvec.iter().filter(|x| **x == 0).next();\n```\nCould be written as\n```rust\nvec.iter().find(|x| **x == 0);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "find_map",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 161
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis lint has been replaced by `manual_find_map`, a\nmore specific lint.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "flat_map_identity",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 626
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `flat_map(|x| x)`.\n\n### Why is this bad?\nReadability, this can be written more concisely by using `flatten`.\n\n### Example\n```rust\niter.flat_map(|x| x);\n```\nCan be written as\n```rust\niter.flatten();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "flat_map_option",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 124
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usages of `Iterator::flat_map()` where `filter_map()` could be\nused instead.\n\n### Why is this bad?\nWhen applicable, `filter_map()` is more clear since it shows that\n`Option` is used to produce 0 or 1 items.\n\n### Example\n```rust\nlet nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().flat_map(|x| x.parse().ok()).collect();\n```\nUse instead:\n```rust\nlet nums: Vec<i32> = [\"1\", \"2\", \"whee!\"].iter().filter_map(|x| x.parse().ok()).collect();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "float_arithmetic",
    "id_span": {
      "path": "src/arithmetic.rs",
      "line": 46
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for float arithmetic.\n\n### Why is this bad?\nFor some embedded systems or kernel development, it\ncan be useful to rule out floating-point numbers.\n\n### Example\n```rust\na + 1.0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "float_cmp",
    "id_span": {
      "path": "src/misc.rs",
      "line": 115
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for (in-)equality comparisons on floating-point\nvalues (apart from zero), except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).\n\n### Why is this bad?\nFloating point calculations are usually imprecise, so\nasking if two values are *exactly* equal is asking for trouble. For a good\nguide on what to do, see [the floating point\nguide](http://www.floating-point-gui.de/errors/comparison).\n\n### Example\n```rust\nlet x = 1.2331f64;\nlet y = 1.2332f64;\n\n// Bad\nif y == 1.23f64 { }\nif y != x {} // where both are floats\n\n// Good\nlet error_margin = f64::EPSILON; // Use an epsilon for comparison\n// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n// let error_margin = std::f64::EPSILON;\nif (y - 1.23f64).abs() < error_margin { }\nif (y - x).abs() > error_margin { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "float_cmp_const",
    "id_span": {
      "path": "src/misc.rs",
      "line": 262
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for (in-)equality comparisons on floating-point\nvalue and constant, except in functions called `*eq*` (which probably\nimplement equality for a type involving floats).\n\n### Why is this bad?\nFloating point calculations are usually imprecise, so\nasking if two values are *exactly* equal is asking for trouble. For a good\nguide on what to do, see [the floating point\nguide](http://www.floating-point-gui.de/errors/comparison).\n\n### Example\n```rust\nlet x: f64 = 1.0;\nconst ONE: f64 = 1.00;\n\n// Bad\nif x == ONE { } // where both are floats\n\n// Good\nlet error_margin = f64::EPSILON; // Use an epsilon for comparison\n// Or, if Rust <= 1.42, use `std::f64::EPSILON` constant instead.\n// let error_margin = std::f64::EPSILON;\nif (x - ONE).abs() < error_margin { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "float_equality_without_abs",
    "id_span": {
      "path": "src/float_equality_without_abs.rs",
      "line": 40
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for statements of the form `(a - b) < f32::EPSILON` or\n`(a - b) < f64::EPSILON`. Notes the missing `.abs()`.\n\n### Why is this bad?\nThe code without `.abs()` is more likely to have a bug.\n\n### Known problems\nIf the user can ensure that b is larger than a, the `.abs()` is\ntechnically unneccessary. However, it will make the code more robust and doesn't have any\nlarge performance implications. If the abs call was deliberately left out for performance\nreasons, it is probably better to state this explicitly in the code, which then can be done\nwith an allow.\n\n### Example\n```rust\npub fn is_roughly_equal(a: f32, b: f32) -> bool {\n    (a - b) < f32::EPSILON\n}\n```\nUse instead:\n```rust\npub fn is_roughly_equal(a: f32, b: f32) -> bool {\n    (a - b).abs() < f32::EPSILON\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "fn_address_comparisons",
    "id_span": {
      "path": "src/unnamed_address.rs",
      "line": 27
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for comparisons with an address of a function item.\n\n### Why is this bad?\nFunction item address is not guaranteed to be unique and could vary\nbetween different code generation units. Furthermore different function items could have\nthe same address after being merged together.\n\n### Example\n```rust\ntype F = fn();\nfn a() {}\nlet f: F = a;\nif f == a {\n    // ...\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "fn_params_excessive_bools",
    "id_span": {
      "path": "src/excessive_bools.rs",
      "line": 79
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for excessive use of\nbools in function definitions.\n\n### Why is this bad?\nCalls to such functions\nare confusing and error prone, because it's\nhard to remember argument order and you have\nno type system support to back you up. Using\ntwo-variant enums instead of bools often makes\nAPI easier to use.\n\n### Example\nBad:\n```rust\nfn f(is_round: bool, is_hot: bool) { ... }\n```\n\nGood:\n```rust\nenum Shape {\n    Round,\n    Spiky,\n}\n\nenum Temperature {\n    Hot,\n    IceCold,\n}\n\nfn f(shape: Shape, temperature: Temperature) { ... }\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `max-fn-params-bools`: `u64`: The maximum number of bool parameters a function can have (defaults to `3`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "fn_to_numeric_cast",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 220
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for casts of function pointers to something other than usize\n\n### Why is this bad?\nCasting a function pointer to anything other than usize/isize is not portable across\narchitectures, because you end up losing bits if the target type is too small or end up with a\nbunch of extra bits that waste space and add more instructions to the final binary than\nstrictly necessary for the problem\n\nCasting to isize also doesn't make sense since there are no signed addresses.\n\n### Example\n```rust\n// Bad\nfn fun() -> i32 { 1 }\nlet a = fun as i64;\n\n// Good\nfn fun2() -> i32 { 1 }\nlet a = fun2 as usize;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "fn_to_numeric_cast_any",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 286
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for casts of a function pointer to any integer type.\n\n### Why is this bad?\nCasting a function pointer to an integer can have surprising results and can occur\naccidentally if parantheses are omitted from a function call. If you aren't doing anything\nlow-level with function pointers then you can opt-out of casting functions to integers in\norder to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\npointer casts in your code.\n\n### Example\n```rust\n// Bad: fn1 is cast as `usize`\nfn fn1() -> u16 {\n    1\n};\nlet _ = fn1 as usize;\n\n// Good: maybe you intended to call the function?\nfn fn2() -> u16 {\n    1\n};\nlet _ = fn2() as usize;\n\n// Good: maybe you intended to cast it to a function type?\nfn fn3() -> u16 {\n    1\n}\nlet _ = fn3 as fn() -> u16;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "fn_to_numeric_cast_with_truncation",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 250
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for casts of a function pointer to a numeric type not wide enough to\nstore address.\n\n### Why is this bad?\nSuch a cast discards some bits of the function's address. If this is intended, it would be more\nclearly expressed by casting to usize first, then casting the usize to the intended type (with\na comment) to perform the truncation.\n\n### Example\n```rust\n// Bad\nfn fn1() -> i16 {\n    1\n};\nlet _ = fn1 as i32;\n\n// Better: Cast to usize first, then comment with the reason for the truncation\nfn fn2() -> i16 {\n    1\n};\nlet fn_ptr = fn2 as usize;\nlet fn_ptr_truncated = fn_ptr as i32;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "for_kv_map",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 367
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for iterating a map (`HashMap` or `BTreeMap`) and\nignoring either the keys or values.\n\n### Why is this bad?\nReadability. There are `keys` and `values` methods that\ncan be used to express that don't need the values or keys.\n\n### Example\n```rust\nfor (k, _) in &map {\n    ..\n}\n```\n\ncould be replaced by\n\n```rust\nfor k in map.keys() {\n    ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "for_loops_over_fallibles",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 204
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for `for` loops over `Option` or `Result` values.\n\n### Why is this bad?\nReadability. This is more clearly expressed as an `if\nlet`.\n\n### Example\n```rust\n\n// Bad\nfor x in opt {\n    // ..\n}\n\n// Good\nif let Some(x) = opt {\n    // ..\n}\n```\n\n// or\n\n```rust\n\n// Bad\nfor x in &res {\n    // ..\n}\n\n// Good\nif let Ok(x) = res {\n    // ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "forget_copy",
    "id_span": {
      "path": "src/drop_forget_ref.rs",
      "line": 97
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calls to `std::mem::forget` with a value that\nderives the Copy trait\n\n### Why is this bad?\nCalling `std::mem::forget` [does nothing for types that\nimplement Copy](https://doc.rust-lang.org/std/mem/fn.drop.html) since the\nvalue will be copied and moved into the function on invocation.\n\nAn alternative, but also valid, explanation is that Copy types do not\nimplement\nthe Drop trait, which means they have no destructors. Without a destructor,\nthere\nis nothing for `std::mem::forget` to ignore.\n\n### Example\n```rust\nlet x: i32 = 42; // i32 implements Copy\nstd::mem::forget(x) // A copy of x is passed to the function, leaving the\n                    // original unaffected\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "forget_ref",
    "id_span": {
      "path": "src/drop_forget_ref.rs",
      "line": 49
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calls to `std::mem::forget` with a reference\ninstead of an owned value.\n\n### Why is this bad?\nCalling `forget` on a reference will only forget the\nreference itself, which is a no-op. It will not forget the underlying\nreferenced\nvalue, which is likely what was intended.\n\n### Example\n```rust\nlet x = Box::new(1);\nstd::mem::forget(&x) // Should have been forget(x), x will still be dropped\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "format_in_format_args",
    "id_span": {
      "path": "src/format_args.rs",
      "line": 34
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nDetects `format!` within the arguments of another macro that does\nformatting such as `format!` itself, `write!` or `println!`. Suggests\ninlining the `format!` call.\n\n### Why is this bad?\nThe recommended code is both shorter and avoids a temporary allocation.\n\n### Example\n```rust\nprintln!(\"error: {}\", format!(\"something failed at {}\", Location::caller()));\n```\nUse instead:\n```rust\nprintln!(\"error: something failed at {}\", Location::caller());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "from_iter_instead_of_collect",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1581
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `from_iter()` function calls on types that implement the `FromIterator`\ntrait.\n\n### Why is this bad?\nIt is recommended style to use collect. See\n[FromIterator documentation](https://doc.rust-lang.org/std/iter/trait.FromIterator.html)\n\n### Example\n```rust\nuse std::iter::FromIterator;\n\nlet five_fives = std::iter::repeat(5).take(5);\n\nlet v = Vec::from_iter(five_fives);\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n```\nUse instead:\n```rust\nlet five_fives = std::iter::repeat(5).take(5);\n\nlet v: Vec<i32> = five_fives.collect();\n\nassert_eq!(v, vec![5, 5, 5, 5, 5]);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "from_over_into",
    "id_span": {
      "path": "src/from_over_into.rs",
      "line": 37
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nSearches for implementations of the `Into<..>` trait and suggests to implement `From<..>` instead.\n\n### Why is this bad?\nAccording the std docs implementing `From<..>` is preferred since it gives you `Into<..>` for free where the reverse isn't true.\n\n### Example\n```rust\nstruct StringWrapper(String);\n\nimpl Into<StringWrapper> for String {\n    fn into(self) -> StringWrapper {\n        StringWrapper(self)\n    }\n}\n```\nUse instead:\n```rust\nstruct StringWrapper(String);\n\nimpl From<String> for StringWrapper {\n    fn from(s: String) -> StringWrapper {\n        StringWrapper(s)\n    }\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "from_str_radix_10",
    "id_span": {
      "path": "src/from_str_radix_10.rs",
      "line": 38
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\n\nChecks for function invocations of the form `primitive::from_str_radix(s, 10)`\n\n### Why is this bad?\n\nThis specific common use case can be rewritten as `s.parse::<primitive>()`\n(and in most cases, the turbofish can be removed), which reduces code length\nand complexity.\n\n### Known problems\n\nThis lint may suggest using (&<expression>).parse() instead of <expression>.parse() directly\nin some cases, which is correct but adds unnecessary complexity to the code.\n\n### Example\n```rust\nlet input: &str = get_input();\nlet num = u16::from_str_radix(input, 10)?;\n```\nUse instead:\n```rust\nlet input: &str = get_input();\nlet num: u16 = input.parse()?;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "future_not_send",
    "id_span": {
      "path": "src/future_not_send.rs",
      "line": 44
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nThis lint requires Future implementations returned from\nfunctions and methods to implement the `Send` marker trait. It is mostly\nused by library authors (public and internal) that target an audience where\nmultithreaded executors are likely to be used for running these Futures.\n\n### Why is this bad?\nA Future implementation captures some state that it\nneeds to eventually produce its final value. When targeting a multithreaded\nexecutor (which is the norm on non-embedded devices) this means that this\nstate may need to be transported to other threads, in other words the\nwhole Future needs to implement the `Send` marker trait. If it does not,\nthen the resulting Future cannot be submitted to a thread pool in the\nend user’s code.\n\nEspecially for generic functions it can be confusing to leave the\ndiscovery of this problem to the end user: the reported error location\nwill be far from its cause and can in many cases not even be fixed without\nmodifying the library where the offending Future implementation is\nproduced.\n\n### Example\n```rust\nasync fn not_send(bytes: std::rc::Rc<[u8]>) {}\n```\nUse instead:\n```rust\nasync fn is_send(bytes: std::sync::Arc<[u8]>) {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "get_last_with_len",
    "id_span": {
      "path": "src/get_last_with_len.rs",
      "line": 42
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for using `x.get(x.len() - 1)` instead of\n`x.last()`.\n\n### Why is this bad?\nUsing `x.last()` is easier to read and has the same\nresult.\n\nNote that using `x[x.len() - 1]` is semantically different from\n`x.last()`.  Indexing into the array will panic on out-of-bounds\naccesses, while `x.get()` and `x.last()` will return `None`.\n\nThere is another lint (get_unwrap) that covers the case of using\n`x.get(index).unwrap()` instead of `x[index]`.\n\n### Example\n```rust\n// Bad\nlet x = vec![2, 3, 5];\nlet last_element = x.get(x.len() - 1);\n\n// Good\nlet x = vec![2, 3, 5];\nlet last_element = x.last();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "get_unwrap",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1078
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for use of `.get().unwrap()` (or\n`.get_mut().unwrap`) on a standard library type which implements `Index`\n\n### Why is this bad?\nUsing the Index trait (`[]`) is more clear and more\nconcise.\n\n### Known problems\nNot a replacement for error handling: Using either\n`.unwrap()` or the Index trait (`[]`) carries the risk of causing a `panic`\nif the value being accessed is `None`. If the use of `.get().unwrap()` is a\ntemporary placeholder for dealing with the `Option` type, then this does\nnot mitigate the need for error handling. If there is a chance that `.get()`\nwill be `None` in your program, then it is advisable that the `None` case\nis handled in a future refactor instead of using `.unwrap()` or the Index\ntrait.\n\n### Example\n```rust\nlet mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec.get(3).unwrap();\n*some_vec.get_mut(0).unwrap() = 1;\n```\nThe correct use would be:\n```rust\nlet mut some_vec = vec![0, 1, 2, 3];\nlet last = some_vec[3];\nsome_vec[0] = 1;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "identity_op",
    "id_span": {
      "path": "src/identity_op.rs",
      "line": 25
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for identity operations, e.g., `x + 0`.\n\n### Why is this bad?\nThis code can be removed without changing the\nmeaning. So it just obscures what's going on. Delete it mercilessly.\n\n### Example\n```rust\nx / 1 + 0 * 1 - 0 | 0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_let_mutex",
    "id_span": {
      "path": "src/if_let_mutex.rs",
      "line": 39
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `Mutex::lock` calls in `if let` expression\nwith lock calls in any of the else blocks.\n\n### Why is this bad?\nThe Mutex lock remains held for the whole\n`if let ... else` block and deadlocks.\n\n### Example\n```rust\nif let Ok(thing) = mutex.lock() {\n    do_thing();\n} else {\n    mutex.lock();\n}\n```\nShould be written\n```rust\nlet locked = mutex.lock();\nif let Ok(thing) = locked {\n    do_thing(thing);\n} else {\n    use_locked(locked);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_let_redundant_pattern_matching",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 107
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThe original rule will only lint for `if let`. After\nmaking it support to lint `match`, naming as `if let` is not suitable for it.\nSo, this lint is deprecated.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_not_else",
    "id_span": {
      "path": "src/if_not_else.rs",
      "line": 42
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `!` or `!=` in an if condition with an\nelse branch.\n\n### Why is this bad?\nNegations reduce the readability of statements.\n\n### Example\n```rust\nif !v.is_empty() {\n    a()\n} else {\n    b()\n}\n```\n\nCould be written:\n\n```rust\nif v.is_empty() {\n    b()\n} else {\n    a()\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_same_then_else",
    "id_span": {
      "path": "src/copies.rs",
      "line": 112
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `if/else` with the same body as the *then* part\nand the *else* part.\n\n### Why is this bad?\nThis is probably a copy & paste error.\n\n### Example\n```rust\nlet foo = if … {\n    42\n} else {\n    42\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_then_some_else_none",
    "id_span": {
      "path": "src/if_then_some_else_none.rs",
      "line": 39
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for if-else that could be written to `bool::then`.\n\n### Why is this bad?\nLooks a little redundant. Using `bool::then` helps it have less lines of code.\n\n### Example\n```rust\nlet a = if v.is_empty() {\n    println!(\"true!\");\n    Some(42)\n} else {\n    None\n};\n```\n\nCould be written:\n\n```rust\nlet a = v.is_empty().then(|| {\n    println!(\"true!\");\n    42\n});\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "ifs_same_cond",
    "id_span": {
      "path": "src/copies.rs",
      "line": 44
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for consecutive `if`s with the same condition.\n\n### Why is this bad?\nThis is probably a copy & paste error.\n\n### Example\n```rust\nif a == b {\n    …\n} else if a == b {\n    …\n}\n```\n\nNote that this lint ignores all conditions with a function call as it could\nhave side effects:\n\n```rust\nif foo() {\n    …\n} else if foo() { // not linted\n    …\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "implicit_clone",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1700
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for the usage of `_.to_owned()`, `vec.to_vec()`, or similar when calling `_.clone()` would be clearer.\n\n### Why is this bad?\nThese methods do the same thing as `_.clone()` but may be confusing as\nto why we are calling `to_vec` on something that is already a `Vec` or calling `to_owned` on something that is already owned.\n\n### Example\n```rust\nlet a = vec![1, 2, 3];\nlet b = a.to_vec();\nlet c = a.to_owned();\n```\nUse instead:\n```rust\nlet a = vec![1, 2, 3];\nlet b = a.clone();\nlet c = a.clone();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "implicit_hasher",
    "id_span": {
      "path": "src/implicit_hasher.rs",
      "line": 57
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for public `impl` or `fn` missing generalization\nover different hashers and implicitly defaulting to the default hashing\nalgorithm (`SipHash`).\n\n### Why is this bad?\n`HashMap` or `HashSet` with custom hashers cannot be\nused with them.\n\n### Known problems\nSuggestions for replacing constructors can contain\nfalse-positives. Also applying suggestions can require modification of other\npieces of code, possibly including external crates.\n\n### Example\n```rust\nimpl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n\npub fn foo(map: &mut HashMap<i32, i32>) { }\n```\ncould be rewritten as\n```rust\nimpl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n\npub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "implicit_return",
    "id_span": {
      "path": "src/implicit_return.rs",
      "line": 38
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for missing return statements at the end of a block.\n\n### Why is this bad?\nActually omitting the return keyword is idiomatic Rust code. Programmers\ncoming from other languages might prefer the expressiveness of `return`. It's possible to miss\nthe last returning statement because the only difference is a missing `;`. Especially in bigger\ncode with multiple return paths having a `return` keyword makes it easier to find the\ncorresponding statements.\n\n### Example\n```rust\nfn foo(x: usize) -> usize {\n    x\n}\n```\nadd return\n```rust\nfn foo(x: usize) -> usize {\n    return x;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "implicit_saturating_sub",
    "id_span": {
      "path": "src/implicit_saturating_sub.rs",
      "line": 33
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for implicit saturating subtraction.\n\n### Why is this bad?\nSimplicity and readability. Instead we can easily use an builtin function.\n\n### Example\n```rust\nlet end: u32 = 10;\nlet start: u32 = 5;\n\nlet mut i: u32 = end - start;\n\n// Bad\nif i != 0 {\n    i -= 1;\n}\n\n// Good\ni = i.saturating_sub(1);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "imprecise_flops",
    "id_span": {
      "path": "src/floating_point_arithmetic.rs",
      "line": 46
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nLooks for floating-point expressions that\ncan be expressed using built-in methods to improve accuracy\nat the cost of performance.\n\n### Why is this bad?\nNegatively impacts accuracy.\n\n### Example\n```rust\nlet a = 3f32;\nlet _ = a.powf(1.0 / 3.0);\nlet _ = (1.0 + a).ln();\nlet _ = a.exp() - 1.0;\n```\n\nis better expressed as\n\n```rust\nlet a = 3f32;\nlet _ = a.cbrt();\nlet _ = a.ln_1p();\nlet _ = a.exp_m1();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "inconsistent_digit_grouping",
    "id_span": {
      "path": "src/literal_representation.rs",
      "line": 81
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nWarns if an integral or floating-point constant is\ngrouped inconsistently with underscores.\n\n### Why is this bad?\nReaders may incorrectly interpret inconsistently\ngrouped digits.\n\n### Example\n```rust\n// Bad\nlet x: u64 = 618_64_9189_73_511;\n\n// Good\nlet x: u64 = 61_864_918_973_511;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "inconsistent_struct_constructor",
    "id_span": {
      "path": "src/inconsistent_struct_constructor.rs",
      "line": 59
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for struct constructors where all fields are shorthand and\nthe order of the field init shorthand in the constructor is inconsistent\nwith the order in the struct definition.\n\n### Why is this bad?\nSince the order of fields in a constructor doesn't affect the\nresulted instance as the below example indicates,\n\n```rust\n#[derive(Debug, PartialEq, Eq)]\nstruct Foo {\n    x: i32,\n    y: i32,\n}\nlet x = 1;\nlet y = 2;\n\n// This assertion never fails:\nassert_eq!(Foo { x, y }, Foo { y, x });\n```\n\ninconsistent order can be confusing and decreases readability and consistency.\n\n### Example\n```rust\nstruct Foo {\n    x: i32,\n    y: i32,\n}\nlet x = 1;\nlet y = 2;\n\nFoo { y, x };\n```\n\nUse instead:\n```rust\nFoo { x, y };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "indexing_slicing",
    "id_span": {
      "path": "src/indexing_slicing.rs",
      "line": 88
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of indexing or slicing. Arrays are special cases, this lint\ndoes report on arrays if we can tell that slicing operations are in bounds and does not\nlint on constant `usize` indexing on arrays because that is handled by rustc's `const_err` lint.\n\n### Why is this bad?\nIndexing and slicing can panic at runtime and there are\nsafe alternatives.\n\n### Known problems\nHopefully none.\n\n### Example\n```rust\n// Vector\nlet x = vec![0; 5];\n\n// Bad\nx[2];\n&x[2..100];\n&x[2..];\n&x[..100];\n\n// Good\nx.get(2);\nx.get(2..100);\nx.get(2..);\nx.get(..100);\n\n// Array\nlet y = [0, 1, 2, 3];\n\n// Bad\n&y[10..100];\n&y[10..];\n&y[..100];\n\n// Good\n&y[2..];\n&y[..2];\n&y[0..3];\ny.get(10);\ny.get(10..100);\ny.get(10..);\ny.get(..100);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "ineffective_bit_mask",
    "id_span": {
      "path": "src/bit_mask.rs",
      "line": 76
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for bit masks in comparisons which can be removed\nwithout changing the outcome. The basic structure can be seen in the\nfollowing table:\n\n|Comparison| Bit Op  |Example    |equals |\n|----------|---------|-----------|-------|\n|`>` / `<=`|`|` / `^`|`x | 2 > 3`|`x > 3`|\n|`<` / `>=`|`|` / `^`|`x ^ 1 < 4`|`x < 4`|\n\n### Why is this bad?\nNot equally evil as [`bad_bit_mask`](#bad_bit_mask),\nbut still a bit misleading, because the bit mask is ineffective.\n\n### Known problems\nFalse negatives: This lint will only match instances\nwhere we have figured out the math (which is for a power-of-two compared\nvalue). This means things like `x | 1 >= 7` (which would be better written\nas `x >= 6`) will not be reported (but bit masks like this are fairly\nuncommon).\n\n### Example\n```rust\nif (x | 1 > 3) {  }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inefficient_to_string",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 840
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `.to_string()` on an `&&T` where\n`T` implements `ToString` directly (like `&&str` or `&&String`).\n\n### Why is this bad?\nThis bypasses the specialized implementation of\n`ToString` and instead goes through the more expensive string formatting\nfacilities.\n\n### Example\n```rust\n// Generic implementation for `T: Display` is used (slow)\n[\"foo\", \"bar\"].iter().map(|s| s.to_string());\n\n// OK, the specialized impl is used\n[\"foo\", \"bar\"].iter().map(|&s| s.to_string());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "infallible_destructuring_match",
    "id_span": {
      "path": "src/matches.rs",
      "line": 367
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for matches being used to destructure a single-variant enum\nor tuple struct where a `let` will suffice.\n\n### Why is this bad?\nJust readability – `let` doesn't nest, whereas a `match` does.\n\n### Example\n```rust\nenum Wrapper {\n    Data(i32),\n}\n\nlet wrapper = Wrapper::Data(42);\n\nlet data = match wrapper {\n    Wrapper::Data(i) => i,\n};\n```\n\nThe correct use would be:\n```rust\nenum Wrapper {\n    Data(i32),\n}\n\nlet wrapper = Wrapper::Data(42);\nlet Wrapper::Data(data) = wrapper;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "infinite_iter",
    "id_span": {
      "path": "src/infinite_iter.rs",
      "line": 23
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for iteration that is guaranteed to be infinite.\n\n### Why is this bad?\nWhile there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.\n\n### Example\n```rust\nuse std::iter;\n\niter::repeat(1_u8).collect::<Vec<_>>();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inherent_to_string",
    "id_span": {
      "path": "src/inherent_to_string.rs",
      "line": 44
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for the definition of inherent methods with a signature of `to_string(&self) -> String`.\n\n### Why is this bad?\nThis method is also implicitly defined if a type implements the `Display` trait. As the functionality of `Display` is much more versatile, it should be preferred.\n\n### Known problems\nNone\n\n### Example\n```rust\n// Bad\npub struct A;\n\nimpl A {\n    pub fn to_string(&self) -> String {\n        \"I am A\".to_string()\n    }\n}\n```\n\n```rust\n// Good\nuse std::fmt;\n\npub struct A;\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"I am A\")\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inherent_to_string_shadow_display",
    "id_span": {
      "path": "src/inherent_to_string.rs",
      "line": 91
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for the definition of inherent methods with a signature of `to_string(&self) -> String` and if the type implementing this method also implements the `Display` trait.\n\n### Why is this bad?\nThis method is also implicitly defined if a type implements the `Display` trait. The less versatile inherent method will then shadow the implementation introduced by `Display`.\n\n### Known problems\nNone\n\n### Example\n```rust\n// Bad\nuse std::fmt;\n\npub struct A;\n\nimpl A {\n    pub fn to_string(&self) -> String {\n        \"I am A\".to_string()\n    }\n}\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"I am A, too\")\n    }\n}\n```\n\n```rust\n// Good\nuse std::fmt;\n\npub struct A;\n\nimpl fmt::Display for A {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"I am A\")\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inline_always",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 67
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for items annotated with `#[inline(always)]`,\nunless the annotated function is empty or simply panics.\n\n### Why is this bad?\nWhile there are valid uses of this annotation (and once\nyou know when to use it, by all means `allow` this lint), it's a common\nnewbie-mistake to pepper one's code with it.\n\nAs a rule of thumb, before slapping `#[inline(always)]` on a function,\nmeasure if that additional function call really affects your runtime profile\nsufficiently to make up for the increase in compile time.\n\n### Known problems\nFalse positives, big time. This lint is meant to be\ndeactivated by everyone doing serious performance work. This means having\ndone the measurement.\n\n### Example\n```rust\n#[inline(always)]\nfn not_quite_hot_code(..) { ... }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inline_asm_x86_att_syntax",
    "id_span": {
      "path": "src/asm_syntax.rs",
      "line": 114
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of AT&T x86 assembly syntax.\n\n### Why is this bad?\nThe lint has been enabled to indicate a preference\nfor Intel x86 assembly syntax.\n\n### Example\n\n```rust\nasm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n```\nUse instead:\n```rust\nasm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inline_asm_x86_intel_syntax",
    "id_span": {
      "path": "src/asm_syntax.rs",
      "line": 78
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of Intel x86 assembly syntax.\n\n### Why is this bad?\nThe lint has been enabled to indicate a preference\nfor AT&T x86 assembly syntax.\n\n### Example\n\n```rust\nasm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n```\nUse instead:\n```rust\nasm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "inline_fn_without_body",
    "id_span": {
      "path": "src/inline_fn_without_body.rs",
      "line": 27
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `#[inline]` on trait methods without bodies\n\n### Why is this bad?\nOnly implementations of trait methods may be inlined.\nThe inline attribute is ignored for trait methods without bodies.\n\n### Example\n```rust\ntrait Animal {\n    #[inline]\n    fn name(&self) -> &'static str;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "inspect_for_each",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1610
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `inspect().for_each()`.\n\n### Why is this bad?\nIt is the same as performing the computation\ninside `inspect` at the beginning of the closure in `for_each`.\n\n### Example\n```rust\n[1,2,3,4,5].iter()\n.inspect(|&x| println!(\"inspect the number: {}\", x))\n.for_each(|&x| {\n    assert!(x >= 0);\n});\n```\nCan be written as\n```rust\n[1,2,3,4,5].iter()\n.for_each(|&x| {\n    println!(\"inspect the number: {}\", x);\n    assert!(x >= 0);\n});\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "int_plus_one",
    "id_span": {
      "path": "src/int_plus_one.rs",
      "line": 31
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n\n### Why is this bad?\nReadability -- better to use `> y` instead of `>= y + 1`.\n\n### Example\n```rust\nif x >= y + 1 {}\n```\n\nCould be written as:\n\n```rust\nif x > y {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "integer_arithmetic",
    "id_span": {
      "path": "src/arithmetic.rs",
      "line": 28
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for integer arithmetic operations which could overflow or panic.\n\nSpecifically, checks for any operators (`+`, `-`, `*`, `<<`, etc) which are capable\nof overflowing according to the [Rust\nReference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\nor which can panic (`/`, `%`). No bounds analysis or sophisticated reasoning is\nattempted.\n\n### Why is this bad?\nInteger overflow will trigger a panic in debug builds or will wrap in\nrelease mode. Division by zero will cause a panic in either mode. In some applications one\nwants explicitly checked, wrapping or saturating arithmetic.\n\n### Example\n```rust\na + 1;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "integer_division",
    "id_span": {
      "path": "src/integer_division.rs",
      "line": 26
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for division of integers\n\n### Why is this bad?\nWhen outside of some very specific algorithms,\ninteger division is very often a mistake because it discards the\nremainder.\n\n### Example\n```rust\n// Bad\nlet x = 3 / 2;\nprintln!(\"{}\", x);\n\n// Good\nlet x = 3f32 / 2f32;\nprintln!(\"{}\", x);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "into_iter_on_ref",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1276
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `into_iter` calls on references which should be replaced by `iter`\nor `iter_mut`.\n\n### Why is this bad?\nReadability. Calling `into_iter` on a reference will not move out its\ncontent into the resulting iterator, which is confusing. It is better just call `iter` or\n`iter_mut` directly.\n\n### Example\n```rust\n// Bad\nlet _ = (&vec![3, 4, 5]).into_iter();\n\n// Good\nlet _ = (&vec![3, 4, 5]).iter();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "invalid_null_ptr_usage",
    "id_span": {
      "path": "src/ptr.rs",
      "line": 146
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nThis lint checks for invalid usages of `ptr::null`.\n\n### Why is this bad?\nThis causes undefined behavior.\n\n### Example\n```rust\n// Bad. Undefined behavior\nunsafe { std::slice::from_raw_parts(ptr::null(), 0); }\n```\n\n```rust\n// Good\nunsafe { std::slice::from_raw_parts(NonNull::dangling().as_ptr(), 0); }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "invalid_regex",
    "id_span": {
      "path": "src/regex.rs",
      "line": 25
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks [regex](https://crates.io/crates/regex) creation\n(with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`) for correct\nregex syntax.\n\n### Why is this bad?\nThis will lead to a runtime panic.\n\n### Example\n```rust\nRegex::new(\"|\")\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "invalid_upcast_comparisons",
    "id_span": {
      "path": "src/invalid_upcast_comparisons.rs",
      "line": 33
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for comparisons where the relation is always either\ntrue or false, but where one side has been upcast so that the comparison is\nnecessary. Only integer types are checked.\n\n### Why is this bad?\nAn expression like `let x : u8 = ...; (x as u32) > 300`\nwill mistakenly imply that it is possible for `x` to be outside the range of\n`u8`.\n\n### Known problems\nhttps://github.com/rust-lang/rust-clippy/issues/886\n\n### Example\n```rust\nlet x: u8 = 1;\n(x as u32) > 300;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "invisible_characters",
    "id_span": {
      "path": "src/unicode.rs",
      "line": 23
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for invisible Unicode characters in the code.\n\n### Why is this bad?\nHaving an invisible character in the code makes for all\nsorts of April fools, but otherwise is very much frowned upon.\n\n### Example\nYou don't see it, but there may be a zero-width space or soft hyphen\nsome­where in this text.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "items_after_statements",
    "id_span": {
      "path": "src/items_after_statements.rs",
      "line": 48
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for items declared after some statement in a block.\n\n### Why is this bad?\nItems live for the entire scope they are declared\nin. But statements are processed in order. This might cause confusion as\nit's hard to figure out which item is meant in a statement.\n\n### Example\n```rust\n// Bad\nfn foo() {\n    println!(\"cake\");\n}\n\nfn main() {\n    foo(); // prints \"foo\"\n    fn foo() {\n        println!(\"foo\");\n    }\n    foo(); // prints \"foo\"\n}\n```\n\n```rust\n// Good\nfn foo() {\n    println!(\"cake\");\n}\n\nfn main() {\n    fn foo() {\n        println!(\"foo\");\n    }\n    foo(); // prints \"foo\"\n    foo(); // prints \"foo\"\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "iter_cloned_collect",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1153
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of `.cloned().collect()` on slice to\ncreate a `Vec`.\n\n### Why is this bad?\n`.to_vec()` is clearer\n\n### Example\n```rust\nlet s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s[..].iter().cloned().collect();\n```\nThe better use would be:\n```rust\nlet s = [1, 2, 3, 4, 5];\nlet s2: Vec<isize> = s.to_vec();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "iter_count",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1725
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of `.iter().count()`.\n\n### Why is this bad?\n`.len()` is more efficient and more\nreadable.\n\n### Example\n```rust\n// Bad\nlet some_vec = vec![0, 1, 2, 3];\nlet _ = some_vec.iter().count();\nlet _ = &some_vec[..].iter().count();\n\n// Good\nlet some_vec = vec![0, 1, 2, 3];\nlet _ = some_vec.len();\nlet _ = &some_vec[..].len();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "iter_next_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 161
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for loops on `x.next()`.\n\n### Why is this bad?\n`next()` returns either `Some(value)` if there was a\nvalue, or `None` otherwise. The insidious thing is that `Option<_>`\nimplements `IntoIterator`, so that possibly one value will be iterated,\nleading to some hard to find bugs. No one will want to write such code\n[except to win an Underhanded Rust\nContest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n\n### Example\n```rust\nfor x in y.next() {\n    ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "iter_next_slice",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1466
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `iter().next()` on a Slice or an Array\n\n### Why is this bad?\nThese can be shortened into `.get()`\n\n### Example\n```rust\na[2..].iter().next();\nb.iter().next();\n```\nshould be written as:\n```rust\na.get(2);\nb.get(0);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "iter_not_returning_iterator",
    "id_span": {
      "path": "src/iter_not_returning_iterator.rs",
      "line": 35
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nDetects methods named `iter` or `iter_mut` that do not have a return type that implements `Iterator`.\n\n### Why is this bad?\nMethods named `iter` or `iter_mut` conventionally return an `Iterator`.\n\n### Example\n```rust\n// `String` does not implement `Iterator`\nstruct Data {}\nimpl Data {\n    fn iter(&self) -> String {\n        todo!()\n    }\n}\n```\nUse instead:\n```rust\nuse std::str::Chars;\nstruct Data {}\nimpl Data {\n   fn iter(&self) -> Chars<'static> {\n       todo!()\n   }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "iter_nth",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1018
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of `.iter().nth()` (and the related\n`.iter_mut().nth()`) on standard library types with *O*(1) element access.\n\n### Why is this bad?\n`.get()` and `.get_mut()` are more efficient and more\nreadable.\n\n### Example\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```\nThe correct use would be:\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.get(3);\nlet bad_slice = &some_vec[..].get(3);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "iter_nth_zero",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 992
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of `iter.nth(0)`.\n\n### Why is this bad?\n`iter.next()` is equivalent to\n`iter.nth(0)`, as they both consume the next element,\n but is more readable.\n\n### Example\n```rust\n// Bad\nlet x = s.iter().nth(0);\n\n// Good\nlet x = s.iter().next();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "iter_skip_next",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1042
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of `.skip(x).next()` on iterators.\n\n### Why is this bad?\n`.nth(x)` is cleaner\n\n### Example\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().skip(3).next();\nlet bad_slice = &some_vec[..].iter().skip(3).next();\n```\nThe correct use would be:\n```rust\nlet some_vec = vec![0, 1, 2, 3];\nlet bad_vec = some_vec.iter().nth(3);\nlet bad_slice = &some_vec[..].iter().nth(3);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "iterator_step_by_zero",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 944
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calling `.step_by(0)` on iterators which panics.\n\n### Why is this bad?\nThis very much looks like an oversight. Use `panic!()` instead if you\nactually intend to panic.\n\n### Example\n```rust\nfor x in (0..100).step_by(0) {\n    //..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "just_underscores_and_digits",
    "id_span": {
      "path": "src/non_expressive_names.rs",
      "line": 65
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks if you have variables whose name consists of just\nunderscores and digits.\n\n### Why is this bad?\nIt's hard to memorize what a variable means without a\ndescriptive name.\n\n### Example\n```rust\nlet _1 = 1;\nlet ___1 = 1;\nlet __1___2 = 11;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "large_const_arrays",
    "id_span": {
      "path": "src/large_const_arrays.rs",
      "line": 30
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for large `const` arrays that should\nbe defined as `static` instead.\n\n### Why is this bad?\nPerformance: const variables are inlined upon use.\nStatic items result in only one instance and has a fixed location in memory.\n\n### Example\n```rust\n// Bad\npub const a = [0u32; 1_000_000];\n\n// Good\npub static a = [0u32; 1_000_000];\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `array-size-threshold`: `u64`: The maximum allowed size for arrays on the stack (defaults to `512000`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "large_digit_groups",
    "id_span": {
      "path": "src/literal_representation.rs",
      "line": 117
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nWarns if the digits of an integral or floating-point\nconstant are grouped into groups that\nare too large.\n\n### Why is this bad?\nNegatively impacts readability.\n\n### Example\n```rust\nlet x: u64 = 6186491_8973511;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "large_enum_variant",
    "id_span": {
      "path": "src/large_enum_variant.rs",
      "line": 43
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for large size differences between variants on\n`enum`s.\n\n### Why is this bad?\nEnum size is bounded by the largest variant. Having a\nlarge variant can penalize the memory layout of that enum.\n\n### Known problems\nThis lint obviously cannot take the distribution of\nvariants in your running program into account. It is possible that the\nsmaller variants make up less than 1% of all instances, in which case\nthe overhead is negligible and the boxing is counter-productive. Always\nmeasure the change this lint suggests.\n\n### Example\n```rust\n// Bad\nenum Test {\n    A(i32),\n    B([i32; 8000]),\n}\n\n// Possibly better\nenum Test2 {\n    A(i32),\n    B(Box<[i32; 8000]>),\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `enum-variant-size-threshold`: `u64`: The maximum size of an enum's variant to avoid box suggestion (defaults to `200`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "large_stack_arrays",
    "id_span": {
      "path": "src/large_stack_arrays.rs",
      "line": 22
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for local arrays that may be too large.\n\n### Why is this bad?\nLarge local arrays may cause stack overflow.\n\n### Example\n```rust\nlet a = [0u32; 1_000_000];\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `array-size-threshold`: `u64`: The maximum allowed size for arrays on the stack (defaults to `512000`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "large_types_passed_by_value",
    "id_span": {
      "path": "src/pass_by_ref_or_value.rs",
      "line": 101
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for functions taking arguments by value, where\nthe argument type is `Copy` and large enough to be worth considering\npassing by reference. Does not trigger if the function is being exported,\nbecause that might induce API breakage, if the parameter is declared as mutable,\nor if the argument is a `self`.\n\n### Why is this bad?\nArguments passed by value might result in an unnecessary\nshallow copy, taking up more space in the stack and requiring a call to\n`memcpy`, which can be expensive.\n\n### Example\n```rust\n#[derive(Clone, Copy)]\nstruct TooLarge([u8; 2048]);\n\n// Bad\nfn foo(v: TooLarge) {}\n```\n```rust\n#[derive(Clone, Copy)]\nstruct TooLarge([u8; 2048]);\n\n// Good\nfn foo(v: &TooLarge) {}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "len_without_is_empty",
    "id_span": {
      "path": "src/len_zero.rs",
      "line": 74
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for items that implement `.len()` but not\n`.is_empty()`.\n\n### Why is this bad?\nIt is good custom to have both methods, because for\nsome data structures, asking about the length will be a costly operation,\nwhereas `.is_empty()` can usually answer in constant time. Also it used to\nlead to false positives on the [`len_zero`](#len_zero) lint – currently that\nlint will ignore such entities.\n\n### Example\n```rust\nimpl X {\n    pub fn len(&self) -> usize {\n        ..\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "len_zero",
    "id_span": {
      "path": "src/len_zero.rs",
      "line": 49
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for getting the length of something via `.len()`\njust to compare to zero, and suggests using `.is_empty()` where applicable.\n\n### Why is this bad?\nSome structures can answer `.is_empty()` much faster\nthan calculating their length. So it is good to get into the habit of using\n`.is_empty()`, and having it is cheap.\nBesides, it makes the intent clearer than a manual comparison in some contexts.\n\n### Example\n```rust\nif x.len() == 0 {\n    ..\n}\nif y.len() != 0 {\n    ..\n}\n```\ninstead use\n```rust\nif x.is_empty() {\n    ..\n}\nif !y.is_empty() {\n    ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "let_and_return",
    "id_span": {
      "path": "src/returns.rs",
      "line": 40
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `let`-bindings, which are subsequently\nreturned.\n\n### Why is this bad?\nIt is just extraneous code. Remove it to make your code\nmore rusty.\n\n### Example\n```rust\nfn foo() -> String {\n    let x = String::new();\n    x\n}\n```\ninstead, use\n```rust\nfn foo() -> String {\n    String::new()\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "let_underscore_drop",
    "id_span": {
      "path": "src/let_underscore.rs",
      "line": 97
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `let _ = <expr>`\nwhere expr has a type that implements `Drop`\n\n### Why is this bad?\nThis statement immediately drops the initializer\nexpression instead of extending its lifetime to the end of the scope, which\nis often not intended. To extend the expression's lifetime to the end of the\nscope, use an underscore-prefixed name instead (i.e. _var). If you want to\nexplicitly drop the expression, `std::mem::drop` conveys your intention\nbetter and is less error-prone.\n\n### Example\n\nBad:\n```rust\nstruct Droppable;\nimpl Drop for Droppable {\n    fn drop(&mut self) {}\n}\n{\n    let _ = Droppable;\n    //               ^ dropped here\n    /* more code */\n}\n```\n\nGood:\n```rust\n{\n    let _droppable = Droppable;\n    /* more code */\n    // dropped at end of scope\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "let_underscore_lock",
    "id_span": {
      "path": "src/let_underscore.rs",
      "line": 56
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `let _ = sync_lock`\n\n### Why is this bad?\nThis statement immediately drops the lock instead of\nextending its lifetime to the end of the scope, which is often not intended.\nTo extend lock lifetime to the end of the scope, use an underscore-prefixed\nname instead (i.e. _lock). If you want to explicitly drop the lock,\n`std::mem::drop` conveys your intention better and is less error-prone.\n\n### Example\n\nBad:\n```rust\nlet _ = mutex.lock();\n```\n\nGood:\n```rust\nlet _lock = mutex.lock();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "let_underscore_must_use",
    "id_span": {
      "path": "src/let_underscore.rs",
      "line": 29
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `let _ = <expr>` where expr is `#[must_use]`\n\n### Why is this bad?\nIt's better to explicitly handle the value of a `#[must_use]`\nexpr\n\n### Example\n```rust\nfn f() -> Result<u32, u32> {\n    Ok(0)\n}\n\nlet _ = f();\n// is_ok() is marked #[must_use]\nlet _ = f().is_ok();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "let_unit_value",
    "id_span": {
      "path": "src/unit_types/mod.rs",
      "line": 24
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for binding a unit value.\n\n### Why is this bad?\nA unit value cannot usefully be used anywhere. So\nbinding one is kind of pointless.\n\n### Example\n```rust\nlet x = {\n    1;\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "linkedlist",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 155
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of any `LinkedList`, suggesting to use a\n`Vec` or a `VecDeque` (formerly called `RingBuf`).\n\n### Why is this bad?\nGankro says:\n\n> The TL;DR of `LinkedList` is that it's built on a massive amount of\npointers and indirection.\n> It wastes memory, it has terrible cache locality, and is all-around slow.\n`RingBuf`, while\n> \"only\" amortized for push/pop, should be faster in the general case for\nalmost every possible\n> workload, and isn't even amortized at all if you can predict the capacity\nyou need.\n>\n> `LinkedList`s are only really good if you're doing a lot of merging or\nsplitting of lists.\n> This is because they can just mangle some pointers instead of actually\ncopying the data. Even\n> if you're doing a lot of insertion in the middle of the list, `RingBuf`\ncan still be better\n> because of how expensive it is to seek to the middle of a `LinkedList`.\n\n### Known problems\nFalse positives – the instances where using a\n`LinkedList` makes sense are few and far between, but they can still happen.\n\n### Example\n```rust\nlet x: LinkedList<usize> = LinkedList::new();\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "logic_bug",
    "id_span": {
      "path": "src/booleans.rs",
      "line": 55
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for boolean expressions that contain terminals that\ncan be eliminated.\n\n### Why is this bad?\nThis is most likely a logic bug.\n\n### Known problems\nIgnores short circuiting behavior.\n\n### Example\n```rust\nif a && b || a { ... }\n```\nThe `b` is unnecessary, the expression is equivalent to `if a`.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "lossy_float_literal",
    "id_span": {
      "path": "src/float_literal.rs",
      "line": 53
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for whole number float literals that\ncannot be represented as the underlying type without loss.\n\n### Why is this bad?\nRust will silently lose precision during\nconversion to a float.\n\n### Example\n```rust\n// Bad\nlet _: f32 = 16_777_217.0; // 16_777_216.0\n\n// Good\nlet _: f32 = 16_777_216.0;\nlet _: f64 = 16_777_217.0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "macro_use_imports",
    "id_span": {
      "path": "src/macro_use.rs",
      "line": 27
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `#[macro_use] use...`.\n\n### Why is this bad?\nSince the Rust 2018 edition you can import\nmacro's directly, this is considered idiomatic.\n\n### Example\n```rust\n#[macro_use]\nuse some_macro;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "main_recursion",
    "id_span": {
      "path": "src/main_recursion.rs",
      "line": 23
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for recursion using the entrypoint.\n\n### Why is this bad?\nApart from special setups (which we could detect following attributes like #![no_std]),\nrecursing into main() seems like an unintuitive antipattern we should be able to detect.\n\n### Example\n```rust\nfn main() {\n    main();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "manual_assert",
    "id_span": {
      "path": "src/manual_assert.rs",
      "line": 29
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nDetects `if`-then-`panic!` that can be replaced with `assert!`.\n\n### Why is this bad?\n`assert!` is simpler than `if`-then-`panic!`.\n\n### Example\n```rust\nlet sad_people: Vec<&str> = vec![];\nif !sad_people.is_empty() {\n    panic!(\"there are sad people: {:?}\", sad_people);\n}\n```\nUse instead:\n```rust\nlet sad_people: Vec<&str> = vec![];\nassert!(sad_people.is_empty(), \"there are sad people: {:?}\", sad_people);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_async_fn",
    "id_span": {
      "path": "src/manual_async_fn.rs",
      "line": 33
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nIt checks for manual implementations of `async` functions.\n\n### Why is this bad?\nIt's more idiomatic to use the dedicated syntax.\n\n### Example\n```rust\nuse std::future::Future;\n\nfn foo() -> impl Future<Output = i32> { async { 42 } }\n```\nUse instead:\n```rust\nasync fn foo() -> i32 { 42 }\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_filter_map",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 556
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.filter(_).map(_)` that can be written more simply\nas `filter_map(_)`.\n\n### Why is this bad?\nRedundant code in the `filter` and `map` operations is poor style and\nless performant.\n\n### Example\nBad:\n```rust\n(0_i32..10)\n    .filter(|n| n.checked_add(1).is_some())\n    .map(|n| n.checked_add(1).unwrap());\n```\n\nGood:\n```rust\n(0_i32..10).filter_map(|n| n.checked_add(1));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_find_map",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 582
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.find(_).map(_)` that can be written more simply\nas `find_map(_)`.\n\n### Why is this bad?\nRedundant code in the `find` and `map` operations is poor style and\nless performant.\n\n### Example\nBad:\n```rust\n(0_i32..10)\n    .find(|n| n.checked_add(1).is_some())\n    .map(|n| n.checked_add(1).unwrap());\n```\n\nGood:\n```rust\n(0_i32..10).find_map(|n| n.checked_add(1));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_flatten",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 540
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nCheck for unnecessary `if let` usage in a for loop\nwhere only the `Some` or `Ok` variant of the iterator element is used.\n\n### Why is this bad?\nIt is verbose and can be simplified\nby first calling the `flatten` method on the `Iterator`.\n\n### Example\n\n```rust\nlet x = vec![Some(1), Some(2), Some(3)];\nfor n in x {\n    if let Some(n) = n {\n        println!(\"{}\", n);\n    }\n}\n```\nUse instead:\n```rust\nlet x = vec![Some(1), Some(2), Some(3)];\nfor n in x.into_iter().flatten() {\n    println!(\"{}\", n);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "manual_map",
    "id_span": {
      "path": "src/manual_map.rs",
      "line": 39
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usages of `match` which could be implemented using `map`\n\n### Why is this bad?\nUsing the `map` method is clearer and more concise.\n\n### Example\n```rust\nmatch Some(0) {\n    Some(x) => Some(x + 1),\n    None => None,\n};\n```\nUse instead:\n```rust\nSome(0).map(|x| x + 1);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_memcpy",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 50
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for for-loops that manually copy items between\nslices that could be optimized by having a memcpy.\n\n### Why is this bad?\nIt is not as fast as a memcpy.\n\n### Example\n```rust\nfor i in 0..src.len() {\n    dst[i + 64] = src[i];\n}\n```\nCould be written as:\n```rust\ndst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "manual_non_exhaustive",
    "id_span": {
      "path": "src/manual_non_exhaustive.rs",
      "line": 55
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for manual implementations of the non-exhaustive pattern.\n\n### Why is this bad?\nUsing the #[non_exhaustive] attribute expresses better the intent\nand allows possible optimizations when applied to enums.\n\n### Example\n```rust\nstruct S {\n    pub a: i32,\n    pub b: i32,\n    _c: (),\n}\n\nenum E {\n    A,\n    B,\n    #[doc(hidden)]\n    _C,\n}\n\nstruct T(pub i32, pub i32, ());\n```\nUse instead:\n```rust\n#[non_exhaustive]\nstruct S {\n    pub a: i32,\n    pub b: i32,\n}\n\n#[non_exhaustive]\nenum E {\n    A,\n    B,\n}\n\n#[non_exhaustive]\nstruct T(pub i32, pub i32);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "manual_ok_or",
    "id_span": {
      "path": "src/manual_ok_or.rs",
      "line": 35
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\n\nFinds patterns that reimplement `Option::ok_or`.\n\n### Why is this bad?\n\nConcise code helps focusing on behavior instead of boilerplate.\n\n### Examples\n```rust\nlet foo: Option<i32> = None;\nfoo.map_or(Err(\"error\"), |v| Ok(v));\n```\n\nUse instead:\n```rust\nlet foo: Option<i32> = None;\nfoo.ok_or(\"error\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_range_contains",
    "id_span": {
      "path": "src/ranges.rs",
      "line": 161
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for expressions like `x >= 3 && x < 8` that could\nbe more readably expressed as `(3..8).contains(x)`.\n\n### Why is this bad?\n`contains` expresses the intent better and has less\nfailure modes (such as fencepost errors or using `||` instead of `&&`).\n\n### Example\n```rust\n// given\nlet x = 6;\n\nassert!(x >= 3 && x < 8);\n```\nUse instead:\n```rust\nassert!((3..8).contains(&x));\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_saturating_arithmetic",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1357
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `.checked_add/sub(x).unwrap_or(MAX/MIN)`.\n\n### Why is this bad?\nThese can be written simply with `saturating_add/sub` methods.\n\n### Example\n```rust\nlet add = x.checked_add(y).unwrap_or(u32::MAX);\nlet sub = x.checked_sub(y).unwrap_or(u32::MIN);\n```\n\ncan be written using dedicated methods for saturating addition/subtraction as:\n\n```rust\nlet add = x.saturating_add(y);\nlet sub = x.saturating_sub(y);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_split_once",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1796
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usages of `str::splitn(2, _)`\n\n### Why is this bad?\n`split_once` is both clearer in intent and slightly more efficient.\n\n### Example\n```rust\n// Bad\n let (key, value) = _.splitn(2, '=').next_tuple()?;\n let value = _.splitn(2, '=').nth(1)?;\n\n// Good\nlet (key, value) = _.split_once('=')?;\nlet value = _.split_once('=')?.1;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_str_repeat",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1774
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for manual implementations of `str::repeat`\n\n### Why is this bad?\nThese are both harder to read, as well as less performant.\n\n### Example\n```rust\n// Bad\nlet x: String = std::iter::repeat('x').take(10).collect();\n\n// Good\nlet x: String = \"x\".repeat(10);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_strip",
    "id_span": {
      "path": "src/manual_strip.rs",
      "line": 45
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nSuggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing using\nthe pattern's length.\n\n### Why is this bad?\nUsing `str:strip_{prefix,suffix}` is safer and may have better performance as there is no\nslicing which may panic and the compiler does not need to insert this panic code. It is\nalso sometimes more readable as it removes the need for duplicating or storing the pattern\nused by `str::{starts,ends}_with` and in the slicing.\n\n### Example\n```rust\nlet s = \"hello, world!\";\nif s.starts_with(\"hello, \") {\n    assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n}\n```\nUse instead:\n```rust\nlet s = \"hello, world!\";\nif let Some(end) = s.strip_prefix(\"hello, \") {\n    assert_eq!(end.to_uppercase(), \"WORLD!\");\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "manual_swap",
    "id_span": {
      "path": "src/swap.rs",
      "line": 38
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for manual swapping.\n\n### Why is this bad?\nThe `std::mem::swap` function exposes the intent better\nwithout deinitializing or copying either variable.\n\n### Example\n```rust\nlet mut a = 42;\nlet mut b = 1337;\n\nlet t = b;\nb = a;\na = t;\n```\nUse std::mem::swap():\n```rust\nlet mut a = 1;\nlet mut b = 2;\nstd::mem::swap(&mut a, &mut b);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "manual_unwrap_or",
    "id_span": {
      "path": "src/manual_unwrap_or.rs",
      "line": 38
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nFinds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n\n### Why is this bad?\nConcise code helps focusing on behavior instead of boilerplate.\n\n### Example\n```rust\nlet foo: Option<i32> = None;\nmatch foo {\n    Some(v) => v,\n    None => 1,\n};\n```\n\nUse instead:\n```rust\nlet foo: Option<i32> = None;\nfoo.unwrap_or(1);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "many_single_char_names",
    "id_span": {
      "path": "src/non_expressive_names.rs",
      "line": 45
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for too many variables whose name consists of a\nsingle character.\n\n### Why is this bad?\nIt's hard to memorize what a variable means without a\ndescriptive name.\n\n### Example\n```rust\nlet (a, b, c, d, e, f, g) = (...);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `single-char-binding-names-threshold`: `u64`: The maximum number of single char bindings a scope may have (defaults to `4`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "map_clone",
    "id_span": {
      "path": "src/map_clone.rs",
      "line": 40
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `map(|x| x.clone())` or\ndereferencing closures for `Copy` types, on `Iterator` or `Option`,\nand suggests `cloned()` or `copied()` instead\n\n### Why is this bad?\nReadability, this can be written more concisely\n\n### Example\n```rust\nlet x = vec![42, 43];\nlet y = x.iter();\nlet z = y.map(|i| *i);\n```\n\nThe correct use would be:\n\n```rust\nlet x = vec![42, 43];\nlet y = x.iter();\nlet z = y.cloned();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "map_collect_result_unit",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1549
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.map(_).collect::<Result<(), _>()`.\n\n### Why is this bad?\nUsing `try_for_each` instead is more readable and idiomatic.\n\n### Example\n```rust\n(0..3).map(|t| Err(t)).collect::<Result<(), _>>();\n```\nUse instead:\n```rust\n(0..3).try_for_each(|t| Err(t));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "map_entry",
    "id_span": {
      "path": "src/entry.rs",
      "line": 57
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for uses of `contains_key` + `insert` on `HashMap`\nor `BTreeMap`.\n\n### Why is this bad?\nUsing `entry` is more efficient.\n\n### Known problems\nThe suggestion may have type inference errors in some cases. e.g.\n```rust\nlet mut map = std::collections::HashMap::new();\nlet _ = if !map.contains_key(&0) {\n    map.insert(0, 0)\n} else {\n    None\n};\n```\n\n### Example\n```rust\nif !map.contains_key(&k) {\n    map.insert(k, v);\n}\n```\ncan both be rewritten as:\n```rust\nmap.entry(k).or_insert(v);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "map_err_ignore",
    "id_span": {
      "path": "src/map_err_ignore.rs",
      "line": 100
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for instances of `map_err(|_| Some::Enum)`\n\n### Why is this bad?\nThis `map_err` throws away the original error rather than allowing the enum to contain and report the cause of the error\n\n### Example\nBefore:\n```rust\nuse std::fmt;\n\n#[derive(Debug)]\nenum Error {\n    Indivisible,\n    Remainder(u8),\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::Indivisible => write!(f, \"could not divide input by three\"),\n            Error::Remainder(remainder) => write!(\n                f,\n                \"input is not divisible by three, remainder = {}\",\n                remainder\n            ),\n        }\n    }\n}\n\nimpl std::error::Error for Error {}\n\nfn divisible_by_3(input: &str) -> Result<(), Error> {\n    input\n        .parse::<i32>()\n        .map_err(|_| Error::Indivisible)\n        .map(|v| v % 3)\n        .and_then(|remainder| {\n            if remainder == 0 {\n                Ok(())\n            } else {\n                Err(Error::Remainder(remainder as u8))\n            }\n        })\n}\n ```\n\n After:\n```rust\nuse std::{fmt, num::ParseIntError};\n\n#[derive(Debug)]\nenum Error {\n    Indivisible(ParseIntError),\n    Remainder(u8),\n}\n\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Error::Indivisible(_) => write!(f, \"could not divide input by three\"),\n            Error::Remainder(remainder) => write!(\n                f,\n                \"input is not divisible by three, remainder = {}\",\n                remainder\n            ),\n        }\n    }\n}\n\nimpl std::error::Error for Error {\n    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {\n        match self {\n            Error::Indivisible(source) => Some(source),\n            _ => None,\n        }\n    }\n}\n\nfn divisible_by_3(input: &str) -> Result<(), Error> {\n    input\n        .parse::<i32>()\n        .map_err(Error::Indivisible)\n        .map(|v| v % 3)\n        .and_then(|remainder| {\n            if remainder == 0 {\n                Ok(())\n            } else {\n                Err(Error::Remainder(remainder as u8))\n            }\n        })\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "map_flatten",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 530
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `_.map(_).flatten(_)` on `Iterator` and `Option`\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.flat_map(_)`\n\n### Example\n```rust\nlet vec = vec![vec![1]];\n\n// Bad\nvec.iter().map(|x| x.iter()).flatten();\n\n// Good\nvec.iter().flat_map(|x| x.iter());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "map_identity",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1654
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for instances of `map(f)` where `f` is the identity function.\n\n### Why is this bad?\nIt can be written more concisely without the call to `map`.\n\n### Example\n```rust\nlet x = [1, 2, 3];\nlet y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n```\nUse instead:\n```rust\nlet x = [1, 2, 3];\nlet y: Vec<_> = x.iter().map(|x| 2*x).collect();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "map_unwrap_or",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 378
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `option.map(_).unwrap_or(_)` or `option.map(_).unwrap_or_else(_)` or\n`result.map(_).unwrap_or_else(_)`.\n\n### Why is this bad?\nReadability, these can be written more concisely (resp.) as\n`option.map_or(_, _)`, `option.map_or_else(_, _)` and `result.map_or_else(_, _)`.\n\n### Known problems\nThe order of the arguments is not in execution order\n\n### Examples\n```rust\n\n// Bad\nx.map(|a| a + 1).unwrap_or(0);\n\n// Good\nx.map_or(0, |a| a + 1);\n```\n\n// or\n\n```rust\n\n// Bad\nx.map(|a| a + 1).unwrap_or_else(some_function);\n\n// Good\nx.map_or_else(some_function, |a| a + 1);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "match_as_ref",
    "id_span": {
      "path": "src/matches.rs",
      "line": 239
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for match which is used to add a reference to an\n`Option` value.\n\n### Why is this bad?\nUsing `as_ref()` or `as_mut()` instead is shorter.\n\n### Example\n```rust\nlet x: Option<()> = None;\n\n// Bad\nlet r: Option<&()> = match x {\n    None => None,\n    Some(ref v) => Some(v),\n};\n\n// Good\nlet r: Option<&()> = x.as_ref();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "match_bool",
    "id_span": {
      "path": "src/matches.rs",
      "line": 169
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for matches where match expression is a `bool`. It\nsuggests to replace the expression with an `if...else` block.\n\n### Why is this bad?\nIt makes the code less readable.\n\n### Example\n```rust\nlet condition: bool = true;\nmatch condition {\n    true => foo(),\n    false => bar(),\n}\n```\nUse if/else instead:\n```rust\nlet condition: bool = true;\nif condition {\n    foo();\n} else {\n    bar();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "match_like_matches_macro",
    "id_span": {
      "path": "src/matches.rs",
      "line": 519
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `match`  or `if let` expressions producing a\n`bool` that could be written using `matches!`\n\n### Why is this bad?\nReadability and needless complexity.\n\n### Known problems\nThis lint falsely triggers, if there are arms with\n`cfg` attributes that remove an arm evaluating to `false`.\n\n### Example\n```rust\nlet x = Some(5);\n\n// Bad\nlet a = match x {\n    Some(0) => true,\n    _ => false,\n};\n\nlet a = if let Some(0) = x {\n    true\n} else {\n    false\n};\n\n// Good\nlet a = matches!(x, Some(0));\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "match_on_vec_items",
    "id_span": {
      "path": "src/match_on_vec_items.rs",
      "line": 43
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `match vec[idx]` or `match vec[n..m]`.\n\n### Why is this bad?\nThis can panic at runtime.\n\n### Example\n```rust\nlet arr = vec![0, 1, 2, 3];\nlet idx = 1;\n\n// Bad\nmatch arr[idx] {\n    0 => println!(\"{}\", 0),\n    1 => println!(\"{}\", 3),\n    _ => {},\n}\n```\nUse instead:\n```rust\nlet arr = vec![0, 1, 2, 3];\nlet idx = 1;\n\n// Good\nmatch arr.get(idx) {\n    Some(0) => println!(\"{}\", 0),\n    Some(1) => println!(\"{}\", 3),\n    _ => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "match_overlapping_arm",
    "id_span": {
      "path": "src/matches.rs",
      "line": 191
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for overlapping match arms.\n\n### Why is this bad?\nIt is likely to be an error and if not, makes the code\nless obvious.\n\n### Example\n```rust\nlet x = 5;\nmatch x {\n    1..=10 => println!(\"1 ... 10\"),\n    5..=15 => println!(\"5 ... 15\"),\n    _ => (),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "match_ref_pats",
    "id_span": {
      "path": "src/matches.rs",
      "line": 135
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for matches where all arms match a reference,\nsuggesting to remove the reference and deref the matched expression\ninstead. It also checks for `if let &foo = bar` blocks.\n\n### Why is this bad?\nIt just makes the code less readable. That reference\ndestructuring adds nothing to the code.\n\n### Example\n```rust\n// Bad\nmatch x {\n    &A(ref y) => foo(y),\n    &B => bar(),\n    _ => frob(&x),\n}\n\n// Good\nmatch *x {\n    A(ref y) => foo(y),\n    B => bar(),\n    _ => frob(x),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "match_result_ok",
    "id_span": {
      "path": "src/match_result_ok.rs",
      "line": 41
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for unnecessary `ok()` in `while let`.\n\n### Why is this bad?\nCalling `ok()` in `while let` is unnecessary, instead match\non `Ok(pat)`\n\n### Example\n```rust\nwhile let Some(value) = iter.next().ok() {\n    vec.push(value)\n}\n\nif let Some(valie) = iter.next().ok() {\n    vec.push(value)\n}\n```\nUse instead:\n```rust\nwhile let Ok(value) = iter.next() {\n    vec.push(value)\n}\n\nif let Ok(value) = iter.next() {\n       vec.push(value)\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "match_same_arms",
    "id_span": {
      "path": "src/matches.rs",
      "line": 563
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `match` with identical arm bodies.\n\n### Why is this bad?\nThis is probably a copy & paste error. If arm bodies\nare the same on purpose, you can factor them\n[using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n\n### Known problems\nFalse positive possible with order dependent `match`\n(see issue\n[#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n\n### Example\n```rust\nmatch foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => bar(), // <= oops\n}\n```\n\nThis should probably be\n```rust\nmatch foo {\n    Bar => bar(),\n    Quz => quz(),\n    Baz => baz(), // <= fixed\n}\n```\n\nor if the original code was not a typo:\n```rust\nmatch foo {\n    Bar | Baz => bar(), // <= shows the intent better\n    Quz => quz(),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "match_single_binding",
    "id_span": {
      "path": "src/matches.rs",
      "line": 398
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for useless match that binds to only one value.\n\n### Why is this bad?\nReadability and needless complexity.\n\n### Known problems\n Suggested replacements may be incorrect when `match`\nis actually binding temporary value, bringing a 'dropped while borrowed' error.\n\n### Example\n```rust\n\n// Bad\nmatch (a, b) {\n    (c, d) => {\n        // useless match\n    }\n}\n\n// Good\nlet (c, d) = (a, b);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "match_str_case_mismatch",
    "id_span": {
      "path": "src/match_str_case_mismatch.rs",
      "line": 42
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `match` expressions modifying the case of a string with non-compliant arms\n\n### Why is this bad?\nThe arm is unreachable, which is likely a mistake\n\n### Example\n```rust\n\nmatch &*text.to_ascii_lowercase() {\n    \"foo\" => {},\n    \"Bar\" => {},\n    _ => {},\n}\n```\nUse instead:\n```rust\n\nmatch &*text.to_ascii_lowercase() {\n    \"foo\" => {},\n    \"bar\" => {},\n    _ => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "match_wild_err_arm",
    "id_span": {
      "path": "src/matches.rs",
      "line": 213
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for arm which matches all errors with `Err(_)`\nand take drastic actions like `panic!`.\n\n### Why is this bad?\nIt is generally a bad practice, similar to\ncatching all exceptions in java with `catch(Exception)`\n\n### Example\n```rust\nlet x: Result<i32, &str> = Ok(3);\nmatch x {\n    Ok(_) => println!(\"ok\"),\n    Err(_) => panic!(\"err\"),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "match_wildcard_for_single_variants",
    "id_span": {
      "path": "src/matches.rs",
      "line": 305
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for wildcard enum matches for a single variant.\n\n### Why is this bad?\nNew enum variants added by library updates can be missed.\n\n### Known problems\nSuggested replacements may not use correct path to enum\nif it's not present in the current scope.\n\n### Example\n```rust\n// Bad\nmatch x {\n    Foo::A => {},\n    Foo::B => {},\n    _ => {},\n}\n\n// Good\nmatch x {\n    Foo::A => {},\n    Foo::B => {},\n    Foo::C => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "maybe_infinite_iter",
    "id_span": {
      "path": "src/infinite_iter.rs",
      "line": 45
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for iteration that may be infinite.\n\n### Why is this bad?\nWhile there may be places where this is acceptable\n(e.g., in event streams), in most cases this is simply an error.\n\n### Known problems\nThe code may have a condition to stop iteration, but\nthis lint is not clever enough to analyze it.\n\n### Example\n```rust\nlet infinite_iter = 0..;\n[0..].iter().zip(infinite_iter.take_while(|x| *x > 5));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mem_forget",
    "id_span": {
      "path": "src/mem_forget.rs",
      "line": 22
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `std::mem::forget(t)` where `t` is\n`Drop`.\n\n### Why is this bad?\n`std::mem::forget(t)` prevents `t` from running its\ndestructor, possibly causing leaks.\n\n### Example\n```rust\nmem::forget(Rc::new(55))\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mem_replace_option_with_none",
    "id_span": {
      "path": "src/mem_replace.rs",
      "line": 38
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `mem::replace()` on an `Option` with\n`None`.\n\n### Why is this bad?\n`Option` already has the method `take()` for\ntaking its current value (Some(..) or None) and replacing it with\n`None`.\n\n### Example\n```rust\nuse std::mem;\n\nlet mut an_option = Some(0);\nlet replaced = mem::replace(&mut an_option, None);\n```\nIs better expressed with:\n```rust\nlet mut an_option = Some(0);\nlet taken = an_option.take();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "mem_replace_with_default",
    "id_span": {
      "path": "src/mem_replace.rs",
      "line": 93
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `std::mem::replace` on a value of type\n`T` with `T::default()`.\n\n### Why is this bad?\n`std::mem` module already has the method `take` to\ntake the current value and replace it with the default value of that type.\n\n### Example\n```rust\nlet mut text = String::from(\"foo\");\nlet replaced = std::mem::replace(&mut text, String::default());\n```\nIs better expressed with:\n```rust\nlet mut text = String::from(\"foo\");\nlet taken = std::mem::take(&mut text);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "mem_replace_with_uninit",
    "id_span": {
      "path": "src/mem_replace.rs",
      "line": 69
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `mem::replace(&mut _, mem::uninitialized())`\nand `mem::replace(&mut _, mem::zeroed())`.\n\n### Why is this bad?\nThis will lead to undefined behavior even if the\nvalue is overwritten later, because the uninitialized value may be\nobserved in the case of a panic.\n\n### Example\n```rust\nuse std::mem;\n\n#[allow(deprecated, invalid_value)]\nfn myfunc (v: &mut Vec<i32>) {\n    let taken_v = unsafe { mem::replace(v, mem::uninitialized()) };\n    let new_v = may_panic(taken_v); // undefined behavior on panic\n    mem::forget(mem::replace(v, new_v));\n}\n```\n\nThe [take_mut](https://docs.rs/take_mut) crate offers a sound solution,\nat the cost of either lazily creating a replacement value or aborting\non panic, to ensure that the uninitialized value cannot be observed.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "min_max",
    "id_span": {
      "path": "src/minmax.rs",
      "line": 29
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for expressions where `std::cmp::min` and `max` are\nused to clamp values, but switched so that the result is constant.\n\n### Why is this bad?\nThis is in all probability not the intended outcome. At\nthe least it hurts readability of the code.\n\n### Example\n```rust\nmin(0, max(100, x))\n```\nor\n```rust\nx.max(100).min(0)\n```\nIt will always be equal to `0`. Probably the author meant to clamp the value\nbetween 0 and 100, but has erroneously swapped `min` and `max`.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "misaligned_transmute",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 83
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis lint should never have applied to non-pointer types, as transmuting\nbetween non-pointer types of differing alignment is well-defined behavior (it's semantically\nequivalent to a memcpy). This lint has thus been refactored into two separate lints:\ncast_ptr_alignment and transmute_ptr_to_ptr.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mismatched_target_os",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 243
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for cfg attributes having operating systems used in target family position.\n\n### Why is this bad?\nThe configuration option will not be recognised and the related item will not be included\nby the conditional compilation engine.\n\n### Example\nBad:\n```rust\n#[cfg(linux)]\nfn conditional() { }\n```\n\nGood:\n```rust\n#[cfg(target_os = \"linux\")]\nfn conditional() { }\n```\n\nOr:\n```rust\n#[cfg(unix)]\nfn conditional() { }\n```\nCheck the [Rust Reference](https://doc.rust-lang.org/reference/conditional-compilation.html#target_os) for more details.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "misrefactored_assign_op",
    "id_span": {
      "path": "src/assign_ops.rs",
      "line": 63
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for `a op= a op b` or `a op= b op a` patterns.\n\n### Why is this bad?\nMost likely these are bugs where one meant to write `a\nop= b`.\n\n### Known problems\nClippy cannot know for sure if `a op= a op b` should have\nbeen `a = a op a op b` or `a = a op b`/`a op= b`. Therefore, it suggests both.\nIf `a op= a op b` is really the correct behaviour it should be\nwritten as `a = a op a op b` as it's less confusing.\n\n### Example\n```rust\nlet mut a = 5;\nlet b = 2;\n// ...\na += a + b;\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "missing_const_for_fn",
    "id_span": {
      "path": "src/missing_const_for_fn.rs",
      "line": 66
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nSuggests the use of `const` in functions and methods where possible.\n\n### Why is this bad?\nNot having the function const prevents callers of the function from being const as well.\n\n### Known problems\nConst functions are currently still being worked on, with some features only being available\non nightly. This lint does not consider all edge cases currently and the suggestions may be\nincorrect if you are using this lint on stable.\n\nAlso, the lint only runs one pass over the code. Consider these two non-const functions:\n\n```rust\nfn a() -> i32 {\n    0\n}\nfn b() -> i32 {\n    a()\n}\n```\n\nWhen running Clippy, the lint will only suggest to make `a` const, because `b` at this time\ncan't be const as it calls a non-const function. Making `a` const and running Clippy again,\nwill suggest to make `b` const, too.\n\n### Example\n```rust\nfn new() -> Self {\n    Self { random_number: 42 }\n}\n```\n\nCould be a const fn:\n\n```rust\nconst fn new() -> Self {\n    Self { random_number: 42 }\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "missing_docs_in_private_items",
    "id_span": {
      "path": "src/missing_doc.rs",
      "line": 30
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nWarns if there is missing doc for any documentable item\n(public or private).\n\n### Why is this bad?\nDoc is good. *rustc* has a `MISSING_DOCS`\nallowed-by-default lint for\npublic members, but has no way to enforce documentation of private items.\nThis lint fixes that.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "missing_enforced_import_renames",
    "id_span": {
      "path": "src/missing_enforced_import_rename.rs",
      "line": 36
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for imports that do not rename the item as specified\nin the `enforce-import-renames` config option.\n\n### Why is this bad?\nConsistency is important, if a project has defined import\nrenames they should be followed. More practically, some item names are too\nvague outside of their defining scope this can enforce a more meaningful naming.\n\n### Example\nAn example clippy.toml configuration:\n```toml\n# clippy.toml\nenforced-import-renames = [ { path = \"serde_json::Value\", rename = \"JsonValue\" }]\n```\n\n```rust\nuse serde_json::Value;\n```\nUse instead:\n```rust\nuse serde_json::Value as JsonValue;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `enforced-import-renames`: `Vec<crate::utils::conf::Rename>`: The list of imports to always rename, a fully qualified path followed by the rename. (defaults to `[]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "missing_errors_doc",
    "id_span": {
      "path": "src/doc.rs",
      "line": 132
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks the doc comments of publicly visible functions that\nreturn a `Result` type and warns if there is no `# Errors` section.\n\n### Why is this bad?\nDocumenting the type of errors that can be returned from a\nfunction can help callers write code to handle the errors appropriately.\n\n### Examples\nSince the following function returns a `Result` it has an `# Errors` section in\nits doc comment:\n\n```rust\n/// # Errors\n///\n/// Will return `Err` if `filename` does not exist or the user does not have\n/// permission to read it.\npub fn read(filename: String) -> io::Result<String> {\n    unimplemented!();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "missing_inline_in_public_items",
    "id_span": {
      "path": "src/missing_inline.rs",
      "line": 55
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nIt lints if an exported function, method, trait method with default impl,\nor trait method impl is not `#[inline]`.\n\n### Why is this bad?\nIn general, it is not. Functions can be inlined across\ncrates when that's profitable as long as any form of LTO is used. When LTO is disabled,\nfunctions that are not `#[inline]` cannot be inlined across crates. Certain types of crates\nmight intend for most of the methods in their public API to be able to be inlined across\ncrates even when LTO is disabled. For these types of crates, enabling this lint might make\nsense. It allows the crate to require all exported methods to be `#[inline]` by default, and\nthen opt out for specific methods where this might not make sense.\n\n### Example\n```rust\npub fn foo() {} // missing #[inline]\nfn ok() {} // ok\n#[inline] pub fn bar() {} // ok\n#[inline(always)] pub fn baz() {} // ok\n\npub trait Bar {\n  fn bar(); // ok\n  fn def_bar() {} // missing #[inline]\n}\n\nstruct Baz;\nimpl Baz {\n   fn private() {} // ok\n}\n\nimpl Bar for Baz {\n  fn bar() {} // ok - Baz is not exported\n}\n\npub struct PubBaz;\nimpl PubBaz {\n   fn private() {} // ok\n   pub fn not_ptrivate() {} // missing #[inline]\n}\n\nimpl Bar for PubBaz {\n   fn bar() {} // missing #[inline]\n   fn def_bar() {} // missing #[inline]\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "missing_panics_doc",
    "id_span": {
      "path": "src/doc.rs",
      "line": 162
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks the doc comments of publicly visible functions that\nmay panic and warns if there is no `# Panics` section.\n\n### Why is this bad?\nDocumenting the scenarios in which panicking occurs\ncan help callers who do not want to panic to avoid those situations.\n\n### Examples\nSince the following function may panic it has a `# Panics` section in\nits doc comment:\n\n```rust\n/// # Panics\n///\n/// Will panic if y is 0\npub fn divide_by(x: i32, y: i32) -> i32 {\n    if y == 0 {\n        panic!(\"Cannot divide by 0\")\n    } else {\n        x / y\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "missing_safety_doc",
    "id_span": {
      "path": "src/doc.rs",
      "line": 104
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for the doc comments of publicly visible\nunsafe functions and warns if there is no `# Safety` section.\n\n### Why is this bad?\nUnsafe functions should document their safety\npreconditions, so that users can be sure they are using them safely.\n\n### Examples\n```rust\n/// This function should really be documented\npub unsafe fn start_apocalypse(u: &mut Universe) {\n    unimplemented!();\n}\n```\n\nAt least write a line about safety:\n\n```rust\n/// # Safety\n///\n/// This function should not be called before the horsemen are ready.\npub unsafe fn start_apocalypse(u: &mut Universe) {\n    unimplemented!();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mistyped_literal_suffixes",
    "id_span": {
      "path": "src/literal_representation.rs",
      "line": 59
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nWarns for mistyped suffix in literals\n\n### Why is this bad?\nThis is most probably a typo\n\n### Known problems\n- Recommends a signed suffix, even though the number might be too big and an unsigned\n  suffix is required\n- Does not match on `_127` since that is a valid grouping for decimal and octal numbers\n\n### Example\n```rust\n// Probably mistyped\n2_32;\n\n// Good\n2_i32;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "mixed_case_hex_literals",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 109
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nWarns on hexadecimal literals with mixed-case letter\ndigits.\n\n### Why is this bad?\nIt looks confusing.\n\n### Example\n```rust\n// Bad\nlet y = 0x1a9BAcD;\n\n// Good\nlet y = 0x1A9BACD;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mod_module_files",
    "id_span": {
      "path": "src/module_style.rs",
      "line": 35
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks that module layout uses only self named module files, bans mod.rs files.\n\n### Why is this bad?\nHaving multiple module layout styles in a project can be confusing.\n\n### Example\n```text\nsrc/\n  stuff/\n    stuff_files.rs\n    mod.rs\n  lib.rs\n```\nUse instead:\n```text\nsrc/\n  stuff/\n    stuff_files.rs\n  stuff.rs\n  lib.rs\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "module_inception",
    "id_span": {
      "path": "src/enum_variants.rs",
      "line": 92
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for modules that have the same name as their\nparent module\n\n### Why is this bad?\nA typical beginner mistake is to have `mod foo;` and\nagain `mod foo { ..\n}` in `foo.rs`.\nThe expectation is that items inside the inner `mod foo { .. }` are then\navailable\nthrough `foo::x`, but they are only available through\n`foo::foo::x`.\nIf this is done on purpose, it would be better to choose a more\nrepresentative module name.\n\n### Example\n```rust\n// lib.rs\nmod foo;\n// foo.rs\nmod foo {\n    ...\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "module_name_repetitions",
    "id_span": {
      "path": "src/enum_variants.rs",
      "line": 62
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nDetects type names that are prefixed or suffixed by the\ncontaining module's name.\n\n### Why is this bad?\nIt requires the user to type the module name twice.\n\n### Example\n```rust\nmod cake {\n    struct BlackForestCake;\n}\n```\nCould be written as:\n```rust\nmod cake {\n    struct BlackForest;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "modulo_arithmetic",
    "id_span": {
      "path": "src/modulo_arithmetic.rs",
      "line": 27
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for modulo arithmetic.\n\n### Why is this bad?\nThe results of modulo (%) operation might differ\ndepending on the language, when negative numbers are involved.\nIf you interop with different languages it might be beneficial\nto double check all places that use modulo arithmetic.\n\nFor example, in Rust `17 % -3 = 2`, but in Python `17 % -3 = -1`.\n\n### Example\n```rust\nlet x = -17 % 3;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "modulo_one",
    "id_span": {
      "path": "src/misc.rs",
      "line": 165
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for getting the remainder of a division by one or minus\none.\n\n### Why is this bad?\nThe result for a divisor of one can only ever be zero; for\nminus one it can cause panic/overflow (if the left operand is the minimal value of\nthe respective integer type) or results in zero. No one will write such code\ndeliberately, unless trying to win an Underhanded Rust Contest. Even for that\ncontest, it's probably a bad idea. Use something more underhanded.\n\n### Example\n```rust\nlet a = x % 1;\nlet a = x % -1;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "multiple_crate_versions",
    "id_span": {
      "path": "src/multiple_crate_versions.rs",
      "line": 36
    },
    "group": "cargo",
    "level": "allow",
    "docs": " ### What it does\nChecks to see if multiple versions of a crate are being\nused.\n\n### Why is this bad?\nThis bloats the size of targets, and can lead to\nconfusing error messages when structs or traits are used interchangeably\nbetween different versions of a crate.\n\n### Known problems\nBecause this can be caused purely by the dependencies\nthemselves, it's not always possible to fix this issue.\n\n### Example\n```toml\n# This will pull in both winapi v0.3.x and v0.2.x, triggering a warning.\n[dependencies]\nctrlc = \"=3.1.0\"\nansi_term = \"=0.11.0\"\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "multiple_inherent_impl",
    "id_span": {
      "path": "src/inherent_impl.rs",
      "line": 39
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for multiple inherent implementations of a struct\n\n### Why is this bad?\nSplitting the implementation of a type makes the code harder to navigate.\n\n### Example\n```rust\nstruct X;\nimpl X {\n    fn one() {}\n}\nimpl X {\n    fn other() {}\n}\n```\n\nCould be written:\n\n```rust\nstruct X;\nimpl X {\n    fn one() {}\n    fn other() {}\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "must_use_candidate",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 158
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for public functions that have no\n`#[must_use]` attribute, but return something not already marked\nmust-use, have no mutable arg and mutate no statics.\n\n### Why is this bad?\nNot bad at all, this lint just shows places where\nyou could add the attribute.\n\n### Known problems\nThe lint only checks the arguments for mutable\ntypes without looking if they are actually changed. On the other hand,\nit also ignores a broad range of potentially interesting side effects,\nbecause we cannot decide whether the programmer intends the function to\nbe called for the side effect or the result. Expect many false\npositives. At least we don't lint if the result type is unit or already\n`#[must_use]`.\n\n### Examples\n```rust\n// this could be annotated with `#[must_use]`.\nfn id<T>(t: T) -> T { t }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "must_use_unit",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 106
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for a `#[must_use]` attribute on\nunit-returning functions and methods.\n\n### Why is this bad?\nUnit values are useless. The attribute is likely\na remnant of a refactoring that removed the return type.\n\n### Examples\n```rust\n#[must_use]\nfn useless() { }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "mut_from_ref",
    "id_span": {
      "path": "src/ptr.rs",
      "line": 124
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nThis lint checks for functions that take immutable\nreferences and return mutable ones.\n\n### Why is this bad?\nThis is trivially unsound, as one can create two\nmutable references from the same (immutable!) source.\nThis [error](https://github.com/rust-lang/rust/issues/39465)\nactually lead to an interim Rust release 1.15.1.\n\n### Known problems\nTo be on the conservative side, if there's at least one\nmutable reference with the output lifetime, this lint will not trigger.\nIn practice, this case is unlikely anyway.\n\n### Example\n```rust\nfn foo(&Foo) -> &mut Bar { .. }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mut_mut",
    "id_span": {
      "path": "src/mut_mut.rs",
      "line": 25
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for instances of `mut mut` references.\n\n### Why is this bad?\nMultiple `mut`s don't add anything meaningful to the\nsource. This is either a copy'n'paste error, or it shows a fundamental\nmisunderstanding of references.\n\n### Example\n```rust\nlet x = &mut &mut y;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mut_mutex_lock",
    "id_span": {
      "path": "src/mut_mutex_lock.rs",
      "line": 41
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `&mut Mutex::lock` calls\n\n### Why is this bad?\n`Mutex::lock` is less efficient than\ncalling `Mutex::get_mut`. In addition you also have a statically\nguarantee that the mutex isn't locked, instead of just a runtime\nguarantee.\n\n### Example\n```rust\nuse std::sync::{Arc, Mutex};\n\nlet mut value_rc = Arc::new(Mutex::new(42_u8));\nlet value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n\nlet mut value = value_mutex.lock().unwrap();\n*value += 1;\n```\nUse instead:\n```rust\nuse std::sync::{Arc, Mutex};\n\nlet mut value_rc = Arc::new(Mutex::new(42_u8));\nlet value_mutex = Arc::get_mut(&mut value_rc).unwrap();\n\nlet value = value_mutex.get_mut().unwrap();\n*value += 1;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "mut_range_bound",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 423
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for loops which have a range bound that is a mutable variable\n\n### Why is this bad?\nOne might think that modifying the mutable variable changes the loop bounds\n\n### Known problems\nFalse positive when mutation is followed by a `break`, but the `break` is not immediately\nafter the mutation:\n\n```rust\nlet mut x = 5;\nfor _ in 0..x {\n    x += 1; // x is a range bound that is mutated\n    ..; // some other expression\n    break; // leaves the loop, so mutation is not an issue\n}\n```\n\nFalse positive on nested loops ([#6072](https://github.com/rust-lang/rust-clippy/issues/6072))\n\n### Example\n```rust\nlet mut foo = 42;\nfor i in 0..foo {\n    foo -= 1;\n    println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mutable_key_type",
    "id_span": {
      "path": "src/mut_key.rs",
      "line": 75
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for sets/maps with mutable key types.\n\n### Why is this bad?\nAll of `HashMap`, `HashSet`, `BTreeMap` and\n`BtreeSet` rely on either the hash or the order of keys be unchanging,\nso having types with interior mutability is a bad idea.\n\n### Known problems\n\n#### False Positives\nIt's correct to use a struct that contains interior mutability as a key, when its\nimplementation of `Hash` or `Ord` doesn't access any of the interior mutable types.\nHowever, this lint is unable to recognize this, so it will often cause false positives in\ntheses cases.  The `bytes` crate is a great example of this.\n\n#### False Negatives\nFor custom `struct`s/`enum`s, this lint is unable to check for interior mutability behind\nindirection.  For example, `struct BadKey<'a>(&'a Cell<usize>)` will be seen as immutable\nand cause a false negative if its implementation of `Hash`/`Ord` accesses the `Cell`.\n\nThis lint does check a few cases for indirection.  Firstly, using some standard library\ntypes (`Option`, `Result`, `Box`, `Rc`, `Arc`, `Vec`, `VecDeque`, `BTreeMap` and\n`BTreeSet`) directly as keys (e.g. in `HashMap<Box<Cell<usize>>, ()>`) **will** trigger the\nlint, because the impls of `Hash`/`Ord` for these types directly call `Hash`/`Ord` on their\ncontained type.\n\nSecondly, the implementations of `Hash` and `Ord` for raw pointers (`*const T` or `*mut T`)\napply only to the **address** of the contained value.  Therefore, interior mutability\nbehind raw pointers (e.g. in `HashSet<*mut Cell<usize>>`) can't impact the value of `Hash`\nor `Ord`, and therefore will not trigger this link.  For more info, see issue\n[#6745](https://github.com/rust-lang/rust-clippy/issues/6745).\n\n### Example\n```rust\nuse std::cmp::{PartialEq, Eq};\nuse std::collections::HashSet;\nuse std::hash::{Hash, Hasher};\nuse std::sync::atomic::AtomicUsize;\n\nstruct Bad(AtomicUsize);\nimpl PartialEq for Bad {\n    fn eq(&self, rhs: &Self) -> bool {\n         ..\n; unimplemented!();\n    }\n}\n\nimpl Eq for Bad {}\n\nimpl Hash for Bad {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n        ..\n; unimplemented!();\n    }\n}\n\nfn main() {\n    let _: HashSet<Bad> = HashSet::new();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mutex_atomic",
    "id_span": {
      "path": "src/mutex_atomic.rs",
      "line": 39
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for usages of `Mutex<X>` where an atomic will do.\n\n### Why is this bad?\nUsing a mutex just to make access to a plain bool or\nreference sequential is shooting flies with cannons.\n`std::sync::atomic::AtomicBool` and `std::sync::atomic::AtomicPtr` are leaner and\nfaster.\n\n### Known problems\nThis lint cannot detect if the mutex is actually used\nfor waiting before a critical section.\n\n### Example\n```rust\n\n// Bad\nlet x = Mutex::new(&y);\n\n// Good\nlet x = AtomicBool::new(y);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mutex_integer",
    "id_span": {
      "path": "src/mutex_atomic.rs",
      "line": 67
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for usages of `Mutex<X>` where `X` is an integral\ntype.\n\n### Why is this bad?\nUsing a mutex just to make access to a plain integer\nsequential is\nshooting flies with cannons. `std::sync::atomic::AtomicUsize` is leaner and faster.\n\n### Known problems\nThis lint cannot detect if the mutex is actually used\nfor waiting before a critical section.\n\n### Example\n```rust\nlet x = Mutex::new(0usize);\n\n// Good\nlet x = AtomicUsize::new(0usize);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "naive_bytecount",
    "id_span": {
      "path": "src/bytecount.rs",
      "line": 33
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for naive byte counts\n\n### Why is this bad?\nThe [`bytecount`](https://crates.io/crates/bytecount)\ncrate has methods to count your bytes faster, especially for large slices.\n\n### Known problems\nIf you have predominantly small slices, the\n`bytecount::count(..)` method may actually be slower. However, if you can\nensure that less than 2³²-1 matches arise, the `naive_count_32(..)` can be\nfaster in those cases.\n\n### Example\n```rust\n&vec.iter().filter(|x| **x == 0u8).count(); // use bytecount::count instead\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "needless_arbitrary_self_type",
    "id_span": {
      "path": "src/needless_arbitrary_self_type.rs",
      "line": 56
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nThe lint checks for `self` in fn parameters that\nspecify the `Self`-type explicitly\n### Why is this bad?\nIncreases the amount and decreases the readability of code\n\n### Example\n```rust\nenum ValType {\n    I32,\n    I64,\n    F32,\n    F64,\n}\n\nimpl ValType {\n    pub fn bytes(self: Self) -> usize {\n        match self {\n            Self::I32 | Self::F32 => 4,\n            Self::I64 | Self::F64 => 8,\n        }\n    }\n}\n```\n\nCould be rewritten as\n\n```rust\nenum ValType {\n    I32,\n    I64,\n    F32,\n    F64,\n}\n\nimpl ValType {\n    pub fn bytes(self) -> usize {\n        match self {\n            Self::I32 | Self::F32 => 4,\n            Self::I64 | Self::F64 => 8,\n        }\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_bitwise_bool",
    "id_span": {
      "path": "src/needless_bitwise_bool.rs",
      "line": 34
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for uses of bitwise and/or operators between booleans, where performance may be improved by using\na lazy and.\n\n### Why is this bad?\nThe bitwise operators do not support short-circuiting, so it may hinder code performance.\nAdditionally, boolean logic \"masked\" as bitwise logic is not caught by lints like `unnecessary_fold`\n\n### Known problems\nThis lint evaluates only when the right side is determined to have no side effects. At this time, that\ndetermination is quite conservative.\n\n### Example\n```rust\nlet (x,y) = (true, false);\nif x & !y {} // where both x and y are booleans\n```\nUse instead:\n```rust\nlet (x,y) = (true, false);\nif x && !y {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_bool",
    "id_span": {
      "path": "src/needless_bool.rs",
      "line": 44
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for expressions of the form `if c { true } else {\nfalse }` (or vice versa) and suggests using the condition directly.\n\n### Why is this bad?\nRedundant code.\n\n### Known problems\nMaybe false positives: Sometimes, the two branches are\npainstakingly documented (which we, of course, do not detect), so they *may*\nhave some value. Even then, the documentation can be rewritten to match the\nshorter code.\n\n### Example\n```rust\nif x {\n    false\n} else {\n    true\n}\n```\nCould be written as\n```rust\n!x\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_borrow",
    "id_span": {
      "path": "src/needless_borrow.rs",
      "line": 40
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for address of operations (`&`) that are going to\nbe dereferenced immediately by the compiler.\n\n### Why is this bad?\nSuggests that the receiver of the expression borrows\nthe expression.\n\n### Example\n```rust\nfn fun(_a: &i32) {}\n\n// Bad\nlet x: &i32 = &&&&&&5;\nfun(&x);\n\n// Good\nlet x: &i32 = &5;\nfun(x);\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_borrowed_reference",
    "id_span": {
      "path": "src/needless_borrowed_ref.rs",
      "line": 41
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for bindings that destructure a reference and borrow the inner\nvalue with `&ref`.\n\n### Why is this bad?\nThis pattern has no effect in almost all cases.\n\n### Known problems\nIn some cases, `&ref` is needed to avoid a lifetime mismatch error.\nExample:\n```rust\nfn foo(a: &Option<String>, b: &Option<String>) {\n    match (a, b) {\n        (None, &ref c) | (&ref c, None) => (),\n        (&Some(ref c), _) => (),\n    };\n}\n```\n\n### Example\nBad:\n```rust\nlet mut v = Vec::<String>::new();\nlet _ = v.iter_mut().filter(|&ref a| a.is_empty());\n```\n\nGood:\n```rust\nlet mut v = Vec::<String>::new();\nlet _ = v.iter_mut().filter(|a| a.is_empty());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_collect",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 257
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for functions collecting an iterator when collect\nis not needed.\n\n### Why is this bad?\n`collect` causes the allocation of a new data structure,\nwhen this allocation may not be needed.\n\n### Example\n```rust\nlet len = iterator.clone().collect::<Vec<_>>().len();\n// should be\nlet len = iterator.count();\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "needless_continue",
    "id_span": {
      "path": "src/needless_continue.rs",
      "line": 113
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nThe lint checks for `if`-statements appearing in loops\nthat contain a `continue` statement in either their main blocks or their\n`else`-blocks, when omitting the `else`-block possibly with some\nrearrangement of code can make the code easier to understand.\n\n### Why is this bad?\nHaving explicit `else` blocks for `if` statements\ncontaining `continue` in their THEN branch adds unnecessary branching and\nnesting to the code. Having an else block containing just `continue` can\nalso be better written by grouping the statements following the whole `if`\nstatement within the THEN block and omitting the else block completely.\n\n### Example\n```rust\nwhile condition() {\n    update_condition();\n    if x {\n        // ...\n    } else {\n        continue;\n    }\n    println!(\"Hello, world\");\n}\n```\n\nCould be rewritten as\n\n```rust\nwhile condition() {\n    update_condition();\n    if x {\n        // ...\n        println!(\"Hello, world\");\n    }\n}\n```\n\nAs another example, the following code\n\n```rust\nloop {\n    if waiting() {\n        continue;\n    } else {\n        // Do something useful\n    }\n}\n```\nCould be rewritten as\n\n```rust\nloop {\n    if waiting() {\n        continue;\n    }\n    // Do something useful\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_doctest_main",
    "id_span": {
      "path": "src/doc.rs",
      "line": 190
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `fn main() { .. }` in doctests\n\n### Why is this bad?\nThe test can be shorter (and likely more readable)\nif the `fn main()` is left implicit.\n\n### Examples\n``````rust\n/// An example of a doctest with a `main()` function\n///\n/// # Examples\n///\n/// ```\n/// fn main() {\n///     // this needs not be in an `fn`\n/// }\n/// ```\nfn needless_main() {\n    unimplemented!();\n}\n``````",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_for_each",
    "id_span": {
      "path": "src/needless_for_each.rs",
      "line": 43
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `for_each` that would be more simply written as a\n`for` loop.\n\n### Why is this bad?\n`for_each` may be used after applying iterator transformers like\n`filter` for better readability and performance. It may also be used to fit a simple\noperation on one line.\nBut when none of these apply, a simple `for` loop is more idiomatic.\n\n### Example\n```rust\nlet v = vec![0, 1, 2];\nv.iter().for_each(|elem| {\n    println!(\"{}\", elem);\n})\n```\nUse instead:\n```rust\nlet v = vec![0, 1, 2];\nfor elem in v.iter() {\n    println!(\"{}\", elem);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_lifetimes",
    "id_span": {
      "path": "src/lifetimes.rs",
      "line": 48
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for lifetime annotations which can be removed by\nrelying on lifetime elision.\n\n### Why is this bad?\nThe additional lifetimes make the code look more\ncomplicated, while there is nothing out of the ordinary going on. Removing\nthem leads to more readable code.\n\n### Known problems\n- We bail out if the function has a `where` clause where lifetimes\nare mentioned due to potenial false positives.\n- Lifetime bounds such as `impl Foo + 'a` and `T: 'a` must be elided with the\nplaceholder notation `'_` because the fully elided notation leaves the type bound to `'static`.\n\n### Example\n```rust\n// Bad: unnecessary lifetime annotations\nfn in_and_out<'a>(x: &'a u8, y: u8) -> &'a u8 {\n    x\n}\n\n// Good\nfn elided(x: &u8, y: u8) -> &u8 {\n    x\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_option_as_deref",
    "id_span": {
      "path": "src/needless_option_as_deref.rs",
      "line": 30
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for no-op uses of Option::{as_deref,as_deref_mut},\nfor example, `Option<&T>::as_deref()` returns the same type.\n\n### Why is this bad?\nRedundant code and improving readability.\n\n### Example\n```rust\nlet a = Some(&1);\nlet b = a.as_deref(); // goes from Option<&i32> to Option<&i32>\n```\nCould be written as:\n```rust\nlet a = Some(&1);\nlet b = a;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_pass_by_value",
    "id_span": {
      "path": "src/needless_pass_by_value.rs",
      "line": 54
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for functions taking arguments by value, but not\nconsuming them in its\nbody.\n\n### Why is this bad?\nTaking arguments by reference is more flexible and can\nsometimes avoid\nunnecessary allocations.\n\n### Known problems\n* This lint suggests taking an argument by reference,\nhowever sometimes it is better to let users decide the argument type\n(by using `Borrow` trait, for example), depending on how the function is used.\n\n### Example\n```rust\nfn foo(v: Vec<i32>) {\n    assert_eq!(v.len(), 42);\n}\n```\nshould be\n```rust\nfn foo(v: &[i32]) {\n    assert_eq!(v.len(), 42);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_question_mark",
    "id_span": {
      "path": "src/needless_question_mark.rs",
      "line": 56
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nSuggests alternatives for useless applications of `?` in terminating expressions\n\n### Why is this bad?\nThere's no reason to use `?` to short-circuit when execution of the body will end there anyway.\n\n### Example\n```rust\nstruct TO {\n    magic: Option<usize>,\n}\n\nfn f(to: TO) -> Option<usize> {\n    Some(to.magic?)\n}\n\nstruct TR {\n    magic: Result<usize, bool>,\n}\n\nfn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n    tr.and_then(|t| Ok(t.magic?))\n}\n\n```\nUse instead:\n```rust\nstruct TO {\n    magic: Option<usize>,\n}\n\nfn f(to: TO) -> Option<usize> {\n   to.magic\n}\n\nstruct TR {\n    magic: Result<usize, bool>,\n}\n\nfn g(tr: Result<TR, bool>) -> Result<usize, bool> {\n    tr.and_then(|t| t.magic)\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_range_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 78
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for looping over the range of `0..len` of some\ncollection just to get the values by index.\n\n### Why is this bad?\nJust iterating the collection itself makes the intent\nmore clear and is probably faster.\n\n### Example\n```rust\nlet vec = vec!['a', 'b', 'c'];\nfor i in 0..vec.len() {\n    println!(\"{}\", vec[i]);\n}\n```\nCould be written as:\n```rust\nlet vec = vec!['a', 'b', 'c'];\nfor i in vec {\n    println!(\"{}\", i);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "needless_return",
    "id_span": {
      "path": "src/returns.rs",
      "line": 65
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for return statements at the end of a block.\n\n### Why is this bad?\nRemoving the `return` and semicolon will make the code\nmore rusty.\n\n### Example\n```rust\nfn foo(x: usize) -> usize {\n    return x;\n}\n```\nsimplify to\n```rust\nfn foo(x: usize) -> usize {\n    x\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "needless_update",
    "id_span": {
      "path": "src/needless_update.rs",
      "line": 43
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for needlessly including a base struct on update\nwhen all fields are changed anyway.\n\nThis lint is not applied to structs marked with\n[non_exhaustive](https://doc.rust-lang.org/reference/attributes/type_system.html).\n\n### Why is this bad?\nThis will cost resources (because the base has to be\nsomewhere), and make the code less readable.\n\n### Example\n```rust\n\n// Bad\nPoint {\n    x: 1,\n    y: 1,\n    z: 1,\n    ..zero_point\n};\n\n// Ok\nPoint {\n    x: 1,\n    y: 1,\n    ..zero_point\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "neg_cmp_op_on_partial_ord",
    "id_span": {
      "path": "src/neg_cmp_op_on_partial_ord.rs",
      "line": 39
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for the usage of negated comparison operators on types which only implement\n`PartialOrd` (e.g., `f64`).\n\n### Why is this bad?\nThese operators make it easy to forget that the underlying types actually allow not only three\npotential Orderings (Less, Equal, Greater) but also a fourth one (Uncomparable). This is\nespecially easy to miss if the operator based comparison result is negated.\n\n### Example\n```rust\nuse std::cmp::Ordering;\n\n// Bad\nlet a = 1.0;\nlet b = f64::NAN;\n\nlet _not_less_or_equal = !(a <= b);\n\n// Good\nlet a = 1.0;\nlet b = f64::NAN;\n\nlet _not_less_or_equal = match a.partial_cmp(&b) {\n    None | Some(Ordering::Greater) => true,\n    _ => false,\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "neg_multiply",
    "id_span": {
      "path": "src/neg_multiply.rs",
      "line": 23
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for multiplication by -1 as a form of negation.\n\n### Why is this bad?\nIt's more readable to just negate.\n\n### Known problems\nThis only catches integers (for now).\n\n### Example\n```rust\nx * -1\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "negative_feature_names",
    "id_span": {
      "path": "src/feature_name.rs",
      "line": 63
    },
    "group": "cargo",
    "level": "allow",
    "docs": " ### What it does\nChecks for negative feature names with prefix `no-` or `not-`\n\n### Why is this bad?\nFeatures are supposed to be additive, and negatively-named features violate it.\n\n### Example\n```toml\n# The `Cargo.toml` with negative feature names\n[features]\ndefault = []\nno-abc = []\nnot-def = []\n\n```\nUse instead:\n```toml\n[features]\ndefault = [\"abc\", \"def\"]\nabc = []\ndef = []\n\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "never_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 388
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for loops that will always `break`, `return` or\n`continue` an outer loop.\n\n### Why is this bad?\nThis loop never loops, all it does is obfuscating the\ncode.\n\n### Example\n```rust\nloop {\n    ..;\n    break;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "new_ret_no_self",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 901
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `new` not returning a type that contains `Self`.\n\n### Why is this bad?\nAs a convention, `new` methods are used to make a new\ninstance of a type.\n\n### Example\nIn an impl block:\n```rust\nimpl Foo {\n    fn new() -> NotAFoo {\n    }\n}\n```\n\n```rust\nstruct Bar(Foo);\nimpl Foo {\n    // Bad. The type name must contain `Self`\n    fn new() -> Bar {\n    }\n}\n```\n\n```rust\nimpl Foo {\n    // Good. Return type contains `Self`\n    fn new() -> Result<Foo, FooError> {\n    }\n}\n```\n\nOr in a trait definition:\n```rust\npub trait Trait {\n    // Bad. The type name must contain `Self`\n    fn new();\n}\n```\n\n```rust\npub trait Trait {\n    // Good. Return type contains `Self`\n    fn new() -> Self;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "new_without_default",
    "id_span": {
      "path": "src/new_without_default.rs",
      "line": 48
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for types with a `fn new() -> Self` method and no\nimplementation of\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html).\n\n### Why is this bad?\nThe user might expect to be able to use\n[`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) as the\ntype can be constructed without arguments.\n\n### Example\n```rust\nstruct Foo(Bar);\n\nimpl Foo {\n    fn new() -> Self {\n        Foo(Bar::new())\n    }\n}\n```\n\nTo fix the lint, add a `Default` implementation that delegates to `new`:\n\n```rust\nstruct Foo(Bar);\n\nimpl Default for Foo {\n    fn default() -> Self {\n        Foo::new()\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "no_effect",
    "id_span": {
      "path": "src/no_effect.rs",
      "line": 25
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for statements which have no effect.\n\n### Why is this bad?\nUnlike dead code, these statements are actually\nexecuted. However, as they have no effect, all they do is make the code less\nreadable.\n\n### Example\n```rust\n0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "no_effect_underscore_binding",
    "id_span": {
      "path": "src/no_effect.rs",
      "line": 47
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for binding to underscore prefixed variable without side-effects.\n\n### Why is this bad?\nUnlike dead code, these bindings are actually\nexecuted. However, as they have no effect and shouldn't be used further on, all they\ndo is make the code less readable.\n\n### Known problems\nFurther usage of this variable is not checked, which can lead to false positives if it is\nused later in the code.\n\n### Example\n```rust\nlet _i_serve_no_purpose = 1;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "non_ascii_literal",
    "id_span": {
      "path": "src/unicode.rs",
      "line": 47
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for non-ASCII characters in string literals.\n\n### Why is this bad?\nYeah, we know, the 90's called and wanted their charset\nback. Even so, there still are editors and other programs out there that\ndon't work well with Unicode. So if the code is meant to be used\ninternationally, on multiple operating systems, or has other portability\nrequirements, activating this lint could be useful.\n\n### Example\n```rust\nlet x = String::from(\"€\");\n```\nCould be written as:\n```rust\nlet x = String::from(\"\\u{20ac}\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "non_octal_unix_permissions",
    "id_span": {
      "path": "src/non_octal_unix_permissions.rs",
      "line": 35
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for non-octal values used to set Unix file permissions.\n\n### Why is this bad?\nThey will be converted into octal, creating potentially\nunintended file permissions.\n\n### Example\n```rust\nuse std::fs::OpenOptions;\nuse std::os::unix::fs::OpenOptionsExt;\n\nlet mut options = OpenOptions::new();\noptions.mode(644);\n```\nUse instead:\n```rust\nuse std::fs::OpenOptions;\nuse std::os::unix::fs::OpenOptionsExt;\n\nlet mut options = OpenOptions::new();\noptions.mode(0o644);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "non_send_fields_in_send_ty",
    "id_span": {
      "path": "src/non_send_fields_in_send_ty.rs",
      "line": 46
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nWarns about fields in struct implementing `Send` that are neither `Send` nor `Copy`.\n\n### Why is this bad?\nSending the struct to another thread will transfer the ownership to\nthe new thread by dropping in the current thread during the transfer.\nThis causes soundness issues for non-`Send` fields, as they are also\ndropped and might not be set up to handle this.\n\nSee:\n* [*The Rustonomicon* about *Send and Sync*](https://doc.rust-lang.org/nomicon/send-and-sync.html)\n* [The documentation of `Send`](https://doc.rust-lang.org/std/marker/trait.Send.html)\n\n### Known Problems\nData structures that contain raw pointers may cause false positives.\nThey are sometimes safe to be sent across threads but do not implement\nthe `Send` trait. This lint has a heuristic to filter out basic cases\nsuch as `Vec<*const T>`, but it's not perfect. Feel free to create an\nissue if you have a suggestion on how this heuristic can be improved.\n\n### Example\n```rust\nstruct ExampleStruct<T> {\n    rc_is_not_send: Rc<String>,\n    unbounded_generic_field: T,\n}\n\n// This impl is unsound because it allows sending `!Send` types through `ExampleStruct`\nunsafe impl<T> Send for ExampleStruct<T> {}\n```\nUse thread-safe types like [`std::sync::Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html)\nor specify correct bounds on generic type parameters (`T: Send`).\n### Configuration\nThis lint has the following configuration variables:\n\n* `enable-raw-pointer-heuristic-for-send`: `bool`: Whether to apply the raw pointer heuristic to determine if a type is `Send`. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "nonminimal_bool",
    "id_span": {
      "path": "src/booleans.rs",
      "line": 34
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for boolean expressions that can be written more\nconcisely.\n\n### Why is this bad?\nReadability of boolean expressions suffers from\nunnecessary duplication.\n\n### Known problems\nIgnores short circuiting behavior of `||` and\n`&&`. Ignores `|`, `&` and `^`.\n\n### Example\n```rust\nif a && true  // should be: if a\nif !(a == b)  // should be: if a != b\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "nonsensical_open_options",
    "id_span": {
      "path": "src/open_options.rs",
      "line": 25
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for duplicate open options as well as combinations\nthat make no sense.\n\n### Why is this bad?\nIn the best case, the code will be harder to read than\nnecessary. I don't know the worst case.\n\n### Example\n```rust\nuse std::fs::OpenOptions;\n\nOpenOptions::new().read(true).truncate(true);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "nonstandard_macro_braces",
    "id_span": {
      "path": "src/nonstandard_macro_braces.rs",
      "line": 32
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks that common macros are used with consistent bracing.\n\n### Why is this bad?\nThis is mostly a consistency lint although using () or []\ndoesn't give you a semicolon in item position, which can be unexpected.\n\n### Example\n```rust\nvec!{1, 2, 3};\n```\nUse instead:\n```rust\nvec![1, 2, 3];\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `standard-macro-braces`: `Vec<crate::nonstandard_macro_braces::MacroMatcher>`: Enforce the named macros always use the braces specified.\n\n    A `MacroMatcher` can be added like so `{ name = \"macro_name\", brace = \"(\" }`. If the macro\n    is could be used with a full path two `MacroMatcher`s have to be added one with the full path\n    `crate_name::macro_name` and one with just the macro name. (defaults to `[]`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "not_unsafe_ptr_arg_deref",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 87
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for public functions that dereference raw pointer\narguments but are not marked `unsafe`.\n\n### Why is this bad?\nThe function should probably be marked `unsafe`, since\nfor an arbitrary raw pointer, there is no way of telling for sure if it is\nvalid.\n\n### Known problems\n* It does not check functions recursively so if the pointer is passed to a\nprivate non-`unsafe` function which does the dereferencing, the lint won't\ntrigger.\n* It only checks for arguments whose type are raw pointers, not raw pointers\ngot from an argument in some other way (`fn foo(bar: &[*const u8])` or\n`some_argument.get_raw_ptr()`).\n\n### Example\n```rust\n// Bad\npub fn foo(x: *const u8) {\n    println!(\"{}\", unsafe { *x });\n}\n\n// Good\npub unsafe fn foo(x: *const u8) {\n    println!(\"{}\", unsafe { *x });\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "ok_expect",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 313
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `ok().expect(..)`.\n\n### Why is this bad?\nBecause you usually call `expect()` on the `Result`\ndirectly to get a better error message.\n\n### Known problems\nThe error type needs to implement `Debug`\n\n### Example\n```rust\n\n// Bad\nx.ok().expect(\"why did I do this again?\");\n\n// Good\nx.expect(\"why did I do this again?\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "op_ref",
    "id_span": {
      "path": "src/eq_op.rs",
      "line": 64
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for arguments to `==` which have their address\ntaken to satisfy a bound\nand suggests to dereference the other argument instead\n\n### Why is this bad?\nIt is more idiomatic to dereference the other argument.\n\n### Known problems\nNone\n\n### Example\n```rust\n// Bad\n&x == y\n\n// Good\nx == *y\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "option_as_ref_deref",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1440
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.as_ref().map(Deref::deref)` or it's aliases (such as String::as_str).\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.as_deref()`.\n\n### Example\n```rust\nopt.as_ref().map(String::as_str)\n```\nCan be written as\n```rust\nopt.as_deref()\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "option_env_unwrap",
    "id_span": {
      "path": "src/option_env_unwrap.rs",
      "line": 29
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for usage of `option_env!(...).unwrap()` and\nsuggests usage of the `env!` macro.\n\n### Why is this bad?\nUnwrapping the result of `option_env!` will panic\nat run-time if the environment variable doesn't exist, whereas `env!`\ncatches it at compile-time.\n\n### Example\n```rust\nlet _ = option_env!(\"HOME\").unwrap();\n```\n\nIs better expressed as:\n\n```rust\nlet _ = env!(\"HOME\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "option_filter_map",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 965
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for indirect collection of populated `Option`\n\n### Why is this bad?\n`Option` is like a collection of 0-1 things, so `flatten`\nautomatically does this without suspicious-looking `unwrap` calls.\n\n### Example\n```rust\nlet _ = std::iter::empty::<Option<i32>>().filter(Option::is_some).map(Option::unwrap);\n```\nUse instead:\n```rust\nlet _ = std::iter::empty::<Option<i32>>().flatten();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "option_if_let_else",
    "id_span": {
      "path": "src/option_if_let_else.rs",
      "line": 62
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nLints usage of `if let Some(v) = ... { y } else { x }` which is more\nidiomatically done with `Option::map_or` (if the else bit is a pure\nexpression) or `Option::map_or_else` (if the else bit is an impure\nexpression).\n\n### Why is this bad?\nUsing the dedicated functions of the `Option` type is clearer and\nmore concise than an `if let` expression.\n\n### Known problems\nThis lint uses a deliberately conservative metric for checking\nif the inside of either body contains breaks or continues which will\ncause it to not suggest a fix if either block contains a loop with\ncontinues or breaks contained within the loop.\n\n### Example\n```rust\nlet _ = if let Some(foo) = optional {\n    foo\n} else {\n    5\n};\nlet _ = if let Some(foo) = optional {\n    foo\n} else {\n    let y = do_complicated_function();\n    y*y\n};\n```\n\nshould be\n\n```rust\nlet _ = optional.map_or(5, |foo| foo);\nlet _ = optional.map_or_else(||{\n    let y = do_complicated_function();\n    y*y\n}, |foo| foo);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "option_map_or_none",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 404
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.map_or(None, _)`.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.and_then(_)`.\n\n### Known problems\nThe order of the arguments is not in execution order.\n\n### Example\n```rust\n\n// Bad\nopt.map_or(None, |a| Some(a + 1));\n\n// Good\nopt.and_then(|a| Some(a + 1));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "option_map_unit_fn",
    "id_span": {
      "path": "src/map_unit_fn.rs",
      "line": 50
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `option.map(f)` where f is a function\nor closure that returns the unit type `()`.\n\n### Why is this bad?\nReadability, this can be written more clearly with\nan if let statement\n\n### Example\n```rust\nlet x: Option<String> = do_stuff();\nx.map(log_err_msg);\nx.map(|msg| log_err_msg(format_msg(msg)));\n```\n\nThe correct use would be:\n\n```rust\nlet x: Option<String> = do_stuff();\nif let Some(msg) = x {\n    log_err_msg(msg);\n}\n\nif let Some(msg) = x {\n    log_err_msg(format_msg(msg));\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "option_option",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 116
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for use of `Option<Option<_>>` in function signatures and type\ndefinitions\n\n### Why is this bad?\n`Option<_>` represents an optional value. `Option<Option<_>>`\nrepresents an optional optional value which is logically the same thing as an optional\nvalue but has an unneeded extra level of wrapping.\n\nIf you have a case where `Some(Some(_))`, `Some(None)` and `None` are distinct cases,\nconsider a custom `enum` instead, with clear names for each case.\n\n### Example\n```rust\nfn get_data() -> Option<Option<u32>> {\n    None\n}\n```\n\nBetter:\n\n```rust\npub enum Contents {\n    Data(Vec<u8>), // Was Some(Some(Vec<u8>))\n    NotYetFetched, // Was Some(None)\n    None,          // Was None\n}\n\nfn get_data() -> Contents {\n    Contents::None\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "or_fun_call",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 713
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`,\netc., and suggests to use `or_else`, `unwrap_or_else`, etc., or\n`unwrap_or_default` instead.\n\n### Why is this bad?\nThe function will always be called and potentially\nallocate an object acting as the default.\n\n### Known problems\nIf the function has side-effects, not calling it will\nchange the semantic of the program, but you shouldn't rely on that anyway.\n\n### Example\n```rust\nfoo.unwrap_or(String::new());\n```\nthis can instead be written:\n```rust\nfoo.unwrap_or_else(String::new);\n```\nor\n```rust\nfoo.unwrap_or_default();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "out_of_bounds_indexing",
    "id_span": {
      "path": "src/indexing_slicing.rs",
      "line": 36
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for out of bounds array indexing with a constant\nindex.\n\n### Why is this bad?\nThis will always panic at runtime.\n\n### Known problems\nHopefully none.\n\n### Example\n```rust\nlet x = [1, 2, 3, 4];\n\n// Bad\nx[9];\n&x[2..9];\n\n// Good\nx[0];\nx[3];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "overflow_check_conditional",
    "id_span": {
      "path": "src/overflow_check_conditional.rs",
      "line": 22
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nDetects classic underflow/overflow checks.\n\n### Why is this bad?\nMost classic C underflow/overflow checks will fail in\nRust. Users can use functions like `overflowing_*` and `wrapping_*` instead.\n\n### Example\n```rust\na + b < a;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "panic",
    "id_span": {
      "path": "src/panic_unimplemented.rs",
      "line": 20
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `panic!`.\n\n### Why is this bad?\n`panic!` will stop the execution of the executable\n\n### Example\n```rust\npanic!(\"even with a good reason\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "panic_in_result_fn",
    "id_span": {
      "path": "src/panic_in_result_fn.rs",
      "line": 33
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `panic!`, `unimplemented!`, `todo!`, `unreachable!` or assertions in a function of type result.\n\n### Why is this bad?\nFor some codebases, it is desirable for functions of type result to return an error instead of crashing. Hence panicking macros should be avoided.\n\n### Known problems\nFunctions called from a function returning a `Result` may invoke a panicking macro. This is not checked.\n\n### Example\n```rust\nfn result_with_panic() -> Result<bool, String>\n{\n    panic!(\"error\");\n}\n```\nUse instead:\n```rust\nfn result_without_panic() -> Result<bool, String> {\n    Err(String::from(\"error\"))\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "panicking_unwrap",
    "id_span": {
      "path": "src/unwrap.rs",
      "line": 68
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calls of `unwrap[_err]()` that will always fail.\n\n### Why is this bad?\nIf panicking is desired, an explicit `panic!()` should be used.\n\n### Known problems\nThis lint only checks `if` conditions not assignments.\nSo something like `let x: Option<()> = None; x.unwrap();` will not be recognized.\n\n### Example\n```rust\nif option.is_none() {\n    do_something_with(option.unwrap())\n}\n```\n\nThis code will always panic. The if condition should probably be inverted.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "partialeq_ne_impl",
    "id_span": {
      "path": "src/partialeq_ne_impl.rs",
      "line": 28
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for manual re-implementations of `PartialEq::ne`.\n\n### Why is this bad?\n`PartialEq::ne` is required to always return the\nnegated result of `PartialEq::eq`, which is exactly what the default\nimplementation does. Therefore, there should never be any need to\nre-implement it.\n\n### Example\n```rust\nstruct Foo;\n\nimpl PartialEq for Foo {\n   fn eq(&self, other: &Foo) -> bool { true }\n   fn ne(&self, other: &Foo) -> bool { !(self == other) }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "path_buf_push_overwrite",
    "id_span": {
      "path": "src/path_buf_push_overwrite.rs",
      "line": 38
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\n* Checks for [push](https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.push)\ncalls on `PathBuf` that can cause overwrites.\n\n### Why is this bad?\nCalling `push` with a root path at the start can overwrite the\nprevious defined path.\n\n### Example\n```rust\nuse std::path::PathBuf;\n\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"/bar\");\nassert_eq!(x, PathBuf::from(\"/bar\"));\n```\nCould be written:\n\n```rust\nuse std::path::PathBuf;\n\nlet mut x = PathBuf::from(\"/foo\");\nx.push(\"bar\");\nassert_eq!(x, PathBuf::from(\"/foo/bar\"));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "pattern_type_mismatch",
    "id_span": {
      "path": "src/pattern_type_mismatch.rs",
      "line": 80
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for patterns that aren't exact representations of the types\nthey are applied to.\n\nTo satisfy this lint, you will have to adjust either the expression that is matched\nagainst or the pattern itself, as well as the bindings that are introduced by the\nadjusted patterns. For matching you will have to either dereference the expression\nwith the `*` operator, or amend the patterns to explicitly match against `&<pattern>`\nor `&mut <pattern>` depending on the reference mutability. For the bindings you need\nto use the inverse. You can leave them as plain bindings if you wish for the value\nto be copied, but you must use `ref mut <variable>` or `ref <variable>` to construct\na reference into the matched structure.\n\nIf you are looking for a way to learn about ownership semantics in more detail, it\nis recommended to look at IDE options available to you to highlight types, lifetimes\nand reference semantics in your code. The available tooling would expose these things\nin a general way even outside of the various pattern matching mechanics. Of course\nthis lint can still be used to highlight areas of interest and ensure a good understanding\nof ownership semantics.\n\n### Why is this bad?\nIt isn't bad in general. But in some contexts it can be desirable\nbecause it increases ownership hints in the code, and will guard against some changes\nin ownership.\n\n### Example\nThis example shows the basic adjustments necessary to satisfy the lint. Note how\nthe matched expression is explicitly dereferenced with `*` and the `inner` variable\nis bound to a shared borrow via `ref inner`.\n\n```rust\n// Bad\nlet value = &Some(Box::new(23));\nmatch value {\n    Some(inner) => println!(\"{}\", inner),\n    None => println!(\"none\"),\n}\n\n// Good\nlet value = &Some(Box::new(23));\nmatch *value {\n    Some(ref inner) => println!(\"{}\", inner),\n    None => println!(\"none\"),\n}\n```\n\nThe following example demonstrates one of the advantages of the more verbose style.\nNote how the second version uses `ref mut a` to explicitly declare `a` a shared mutable\nborrow, while `b` is simply taken by value. This ensures that the loop body cannot\naccidentally modify the wrong part of the structure.\n\n```rust\n// Bad\nlet mut values = vec![(2, 3), (3, 4)];\nfor (a, b) in &mut values {\n    *a += *b;\n}\n\n// Good\nlet mut values = vec![(2, 3), (3, 4)];\nfor &mut (ref mut a, b) in &mut values {\n    *a += b;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "possible_missing_comma",
    "id_span": {
      "path": "src/formatting.rs",
      "line": 102
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for possible missing comma in an array. It lints if\nan array element is a binary operator expression and it lies on two lines.\n\n### Why is this bad?\nThis could lead to unexpected results.\n\n### Example\n```rust\nlet a = &[\n    -1, -2, -3 // <= no comma here\n    -4, -5, -6\n];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "precedence",
    "id_span": {
      "path": "src/precedence.rs",
      "line": 45
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for operations where precedence may be unclear\nand suggests to add parentheses. Currently it catches the following:\n* mixed usage of arithmetic and bit shifting/combining operators without\nparentheses\n* a \"negative\" numeric literal (which is really a unary `-` followed by a\nnumeric literal)\n  followed by a method call\n\n### Why is this bad?\nNot everyone knows the precedence of those operators by\nheart, so expressions like these may trip others trying to reason about the\ncode.\n\n### Example\n* `1 << 2 + 3` equals 32, while `(1 << 2) + 3` equals 7\n* `-1i32.abs()` equals -1, while `(-1i32).abs()` equals 1",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "print_literal",
    "id_span": {
      "path": "src/write.rs",
      "line": 145
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns about the use of literals as `print!`/`println!` args.\n\n### Why is this bad?\nUsing literals as `println!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)\n\n### Known problems\nWill also warn with macro calls as arguments that expand to literals\n-- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n\n### Example\n```rust\nprintln!(\"{}\", \"foo\");\n```\nuse the literal without formatting:\n```rust\nprintln!(\"foo\");\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "print_stderr",
    "id_span": {
      "path": "src/write.rs",
      "line": 100
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for printing on *stderr*. The purpose of this lint\nis to catch debugging remnants.\n\n### Why is this bad?\nPeople often print on *stderr* while debugging an\napplication and might forget to remove those prints afterward.\n\n### Known problems\nOnly catches `eprint!` and `eprintln!` calls.\n\n### Example\n```rust\neprintln!(\"Hello world!\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "print_stdout",
    "id_span": {
      "path": "src/write.rs",
      "line": 79
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for printing on *stdout*. The purpose of this lint\nis to catch debugging remnants.\n\n### Why is this bad?\nPeople often print on *stdout* while debugging an\napplication and might forget to remove those prints afterward.\n\n### Known problems\nOnly catches `print!` and `println!` calls.\n\n### Example\n```rust\nprintln!(\"Hello world!\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "print_with_newline",
    "id_span": {
      "path": "src/write.rs",
      "line": 58
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns when you use `print!()` with a format\nstring that ends in a newline.\n\n### Why is this bad?\nYou should use `println!()` instead, which appends the\nnewline.\n\n### Example\n```rust\nprint!(\"Hello {}!\\n\", name);\n```\nuse println!() instead\n```rust\nprintln!(\"Hello {}!\", name);\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "println_empty_string",
    "id_span": {
      "path": "src/write.rs",
      "line": 34
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns when you use `println!(\"\")` to\nprint a newline.\n\n### Why is this bad?\nYou should use `println!()`, which is simpler.\n\n### Example\n```rust\n// Bad\nprintln!(\"\");\n\n// Good\nprintln!();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "ptr_arg",
    "id_span": {
      "path": "src/ptr.rs",
      "line": 73
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint checks for function arguments of type `&String`\nor `&Vec` unless the references are mutable. It will also suggest you\nreplace `.clone()` calls with the appropriate `.to_owned()`/`to_string()`\ncalls.\n\n### Why is this bad?\nRequiring the argument to be of the specific size\nmakes the function less useful for no benefit; slices in the form of `&[T]`\nor `&str` usually suffice and can be obtained from other types, too.\n\n### Known problems\nThe lint does not follow data. So if you have an\nargument `x` and write `let y = x; y.clone()` the lint will not suggest\nchanging that `.clone()` to `.to_owned()`.\n\nOther functions called from this function taking a `&String` or `&Vec`\nargument may also fail to compile if you change the argument. Applying\nthis lint on them will fix the problem, but they may be in other crates.\n\nOne notable example of a function that may cause issues, and which cannot\neasily be changed due to being in the standard library is `Vec::contains`.\nwhen called on a `Vec<Vec<T>>`. If a `&Vec` is passed to that method then\nit will compile, but if a `&[T]` is passed then it will not compile.\n\n```rust\nfn cannot_take_a_slice(v: &Vec<u8>) -> bool {\n    let vec_of_vecs: Vec<Vec<u8>> = some_other_fn();\n\n    vec_of_vecs.contains(v)\n}\n```\n\nAlso there may be `fn(&Vec)`-typed references pointing to your function.\nIf you have them, you will get a compiler error after applying this lint's\nsuggestions. You then have the choice to undo your changes or change the\ntype of the reference.\n\nNote that if the function is part of your public interface, there may be\nother crates referencing it, of which you may not be aware. Carefully\ndeprecate the function before applying the lint suggestions in this case.\n\n### Example\n```rust\n// Bad\nfn foo(&Vec<u32>) { .. }\n\n// Good\nfn foo(&[u32]) { .. }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "ptr_as_ptr",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 375
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `as` casts between raw pointers without changing its mutability,\nnamely `*const T` to `*const U` and `*mut T` to `*mut U`.\n\n### Why is this bad?\nThough `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\nit cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n\n### Example\n```rust\nlet ptr: *const u32 = &42_u32;\nlet mut_ptr: *mut u32 = &mut 42_u32;\nlet _ = ptr as *const i32;\nlet _ = mut_ptr as *mut i32;\n```\nUse instead:\n```rust\nlet ptr: *const u32 = &42_u32;\nlet mut_ptr: *mut u32 = &mut 42_u32;\nlet _ = ptr.cast::<i32>();\nlet _ = mut_ptr.cast::<i32>();\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "ptr_eq",
    "id_span": {
      "path": "src/ptr_eq.rs",
      "line": 33
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nUse `std::ptr::eq` when applicable\n\n### Why is this bad?\n`ptr::eq` can be used to compare `&T` references\n(which coerce to `*const T` implicitly) by their address rather than\ncomparing the values they point to.\n\n### Example\n```rust\nlet a = &[1, 2, 3];\nlet b = &[1, 2, 3];\n\nassert!(a as *const _ as usize == b as *const _ as usize);\n```\nUse instead:\n```rust\nlet a = &[1, 2, 3];\nlet b = &[1, 2, 3];\n\nassert!(std::ptr::eq(a, b));\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "ptr_offset_with_cast",
    "id_span": {
      "path": "src/ptr_offset_with_cast.rs",
      "line": 41
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of the `offset` pointer method with a `usize` casted to an\n`isize`.\n\n### Why is this bad?\nIf we’re always increasing the pointer address, we can avoid the numeric\ncast by using the `add` method instead.\n\n### Example\n```rust\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\n\nunsafe {\n    ptr.offset(offset as isize);\n}\n```\n\nCould be written:\n\n```rust\nlet vec = vec![b'a', b'b', b'c'];\nlet ptr = vec.as_ptr();\nlet offset = 1_usize;\n\nunsafe {\n    ptr.add(offset);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "pub_enum_variant_names",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 184
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThe `avoid_breaking_exported_api` config option was added, which\nenables the `enum_variant_names` lint for public items.\n```rust",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "question_mark",
    "id_span": {
      "path": "src/question_mark.rs",
      "line": 35
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for expressions that could be replaced by the question mark operator.\n\n### Why is this bad?\nQuestion mark usage is more idiomatic.\n\n### Example\n```rust\nif option.is_none() {\n    return None;\n}\n```\n\nCould be written:\n\n```rust\noption?;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "range_minus_one",
    "id_span": {
      "path": "src/ranges.rs",
      "line": 103
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for inclusive ranges where 1 is subtracted from\nthe upper bound, e.g., `x..=(y-1)`.\n\n### Why is this bad?\nThe code is more readable with an exclusive range\nlike `x..y`.\n\n### Known problems\nThis will cause a warning that cannot be fixed if\nthe consumer of the range only accepts a specific range type, instead of\nthe generic `RangeBounds` trait\n([#3307](https://github.com/rust-lang/rust-clippy/issues/3307)).\n\n### Example\n```rust\nfor x..=(y-1) { .. }\n```\nCould be written as\n```rust\nfor x..y { .. }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "range_plus_one",
    "id_span": {
      "path": "src/ranges.rs",
      "line": 75
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for exclusive ranges where 1 is added to the\nupper bound, e.g., `x..(y+1)`.\n\n### Why is this bad?\nThe code is more readable with an inclusive range\nlike `x..=y`.\n\n### Known problems\nWill add unnecessary pair of parentheses when the\nexpression is not wrapped in a pair but starts with an opening parenthesis\nand ends with a closing one.\nI.e., `let _ = (f()+1)..(f()+1)` results in `let _ = ((f()+1)..=f())`.\n\nAlso in many cases, inclusive ranges are still slower to run than\nexclusive ranges, because they essentially add an extra branch that\nLLVM may fail to hoist out of the loop.\n\nThis will cause a warning that cannot be fixed if the consumer of the\nrange only accepts a specific range type, instead of the generic\n`RangeBounds` trait\n([#3307](https://github.com/rust-lang/rust-clippy/issues/3307)).\n\n### Example\n```rust\nfor x..(y+1) { .. }\n```\nCould be written as\n```rust\nfor x..=y { .. }\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "range_step_by_zero",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 48
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\n`Range::step_by(0)` used to be linted since it's\nan infinite iterator, which is better expressed by `iter::repeat`,\nbut the method has been removed for `Iterator::step_by` which panics\nif given a zero",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "range_zip_with_len",
    "id_span": {
      "path": "src/ranges.rs",
      "line": 38
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for zipping a collection with the range of\n`0.._.len()`.\n\n### Why is this bad?\nThe code is better expressed with `.enumerate()`.\n\n### Example\n```rust\nx.iter().zip(0..x.len());\n```\nCould be written as\n```rust\nx.iter().enumerate();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "rc_buffer",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 237
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `Rc<T>` and `Arc<T>` when `T` is a mutable buffer type such as `String` or `Vec`.\n\n### Why is this bad?\nExpressions such as `Rc<String>` usually have no advantage over `Rc<str>`, since\nit is larger and involves an extra level of indirection, and doesn't implement `Borrow<str>`.\n\nWhile mutating a buffer type would still be possible with `Rc::get_mut()`, it only\nworks if there are no additional references yet, which usually defeats the purpose of\nenclosing it in a shared ownership type. Instead, additionally wrapping the inner\ntype with an interior mutable container (such as `RefCell` or `Mutex`) would normally\nbe used.\n\n### Known problems\nThis pattern can be desirable to avoid the overhead of a `RefCell` or `Mutex` for\ncases where mutation only happens before there are any additional references.\n\n### Example\n```rust\nfn foo(interned: Rc<String>) { ... }\n```\n\nBetter:\n\n```rust\nfn foo(interned: Rc<str>) { ... }\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "rc_mutex",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 290
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `Rc<Mutex<T>>`.\n\n### Why is this bad?\n`Rc` is used in single thread and `Mutex` is used in multi thread.\nConsider using `Rc<RefCell<T>>` in single thread or `Arc<Mutex<T>>` in multi thread.\n\n### Known problems\nSometimes combining generic types can lead to the requirement that a\ntype use Rc in conjunction with Mutex. We must consider those cases false positives, but\nalas they are quite hard to rule out. Luckily they are also rare.\n\n### Example\n```rust\nuse std::rc::Rc;\nuse std::sync::Mutex;\nfn foo(interned: Rc<Mutex<i32>>) { ... }\n```\n\nBetter:\n\n```rust\nuse std::rc::Rc;\nuse std::cell::RefCell\nfn foo(interned: Rc<RefCell<i32>>) { ... }\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "redundant_allocation",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 203
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of redundant allocations anywhere in the code.\n\n### Why is this bad?\nExpressions such as `Rc<&T>`, `Rc<Rc<T>>`, `Rc<Arc<T>>`, `Rc<Box<T>>`, `Arc<&T>`, `Arc<Rc<T>>`,\n`Arc<Arc<T>>`, `Arc<Box<T>>`, `Box<&T>`, `Box<Rc<T>>`, `Box<Arc<T>>`, `Box<Box<T>>`, add an unnecessary level of indirection.\n\n### Example\n```rust\nfn foo(bar: Rc<&usize>) {}\n```\n\nBetter:\n\n```rust\nfn foo(bar: &usize) {}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "redundant_clone",
    "id_span": {
      "path": "src/redundant_clone.rs",
      "line": 65
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for a redundant `clone()` (and its relatives) which clones an owned\nvalue that is going to be dropped without further use.\n\n### Why is this bad?\nIt is not always possible for the compiler to eliminate useless\nallocations and deallocations generated by redundant `clone()`s.\n\n### Known problems\nFalse-negatives: analysis performed by this lint is conservative and limited.\n\n### Example\n```rust\n{\n    let x = Foo::new();\n    call(x.clone());\n    call(x.clone()); // this can just pass `x`\n}\n\n[\"lorem\", \"ipsum\"].join(\" \").to_string();\n\nPath::new(\"/a/b\").join(\"c\").to_path_buf();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "redundant_closure",
    "id_span": {
      "path": "src/eta_reduction.rs",
      "line": 42
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for closures which just call another function where\nthe function can be called directly. `unsafe` functions or calls where types\nget adjusted are ignored.\n\n### Why is this bad?\nNeedlessly creating a closure adds code for no benefit\nand gives the optimizer more work.\n\n### Known problems\nIf creating the closure inside the closure has a side-\neffect then moving the closure creation out will change when that side-\neffect runs.\nSee [#1439](https://github.com/rust-lang/rust-clippy/issues/1439) for more details.\n\n### Example\n```rust\n// Bad\nxs.map(|x| foo(x))\n\n// Good\nxs.map(foo)\n```\nwhere `foo(_)` is a plain function that takes the exact argument type of\n`x`.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "redundant_closure_call",
    "id_span": {
      "path": "src/redundant_closure_call.rs",
      "line": 33
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nDetects closures called in the same expression where they\nare defined.\n\n### Why is this bad?\nIt is unnecessarily adding to the expression's\ncomplexity.\n\n### Example\n```rust\n// Bad\nlet a = (|| 42)()\n\n// Good\nlet a = 42\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "redundant_closure_for_method_calls",
    "id_span": {
      "path": "src/eta_reduction.rs",
      "line": 63
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for closures which only invoke a method on the closure\nargument and can be replaced by referencing the method directly.\n\n### Why is this bad?\nIt's unnecessary to create the closure.\n\n### Example\n```rust\nSome('a').map(|s| s.to_uppercase());\n```\nmay be rewritten as\n```rust\nSome('a').map(char::to_uppercase);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "redundant_else",
    "id_span": {
      "path": "src/redundant_else.rs",
      "line": 39
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `else` blocks that can be removed without changing semantics.\n\n### Why is this bad?\nThe `else` block adds unnecessary indentation and verbosity.\n\n### Known problems\nSome may prefer to keep the `else` block for clarity.\n\n### Example\n```rust\nfn my_func(count: u32) {\n    if count == 0 {\n        print!(\"Nothing to do\");\n        return;\n    } else {\n        print!(\"Moving on...\");\n    }\n}\n```\nUse instead:\n```rust\nfn my_func(count: u32) {\n    if count == 0 {\n        print!(\"Nothing to do\");\n        return;\n    }\n    print!(\"Moving on...\");\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "redundant_feature_names",
    "id_span": {
      "path": "src/feature_name.rs",
      "line": 34
    },
    "group": "cargo",
    "level": "allow",
    "docs": " ### What it does\nChecks for feature names with prefix `use-`, `with-` or suffix `-support`\n\n### Why is this bad?\nThese prefixes and suffixes have no significant meaning.\n\n### Example\n```toml\n# The `Cargo.toml` with feature name redundancy\n[features]\ndefault = [\"use-abc\", \"with-def\", \"ghi-support\"]\nuse-abc = []  // redundant\nwith-def = []   // redundant\nghi-support = []   // redundant\n```\n\nUse instead:\n```toml\n[features]\ndefault = [\"abc\", \"def\", \"ghi\"]\nabc = []\ndef = []\nghi = []\n```\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "redundant_field_names",
    "id_span": {
      "path": "src/redundant_field_names.rs",
      "line": 33
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for fields in struct literals where shorthands\ncould be used.\n\n### Why is this bad?\nIf the field and variable names are the same,\nthe field name is redundant.\n\n### Example\n```rust\nlet bar: u8 = 123;\n\nstruct Foo {\n    bar: u8,\n}\n\nlet foo = Foo { bar: bar };\n```\nthe last line can be simplified to\n```rust\nlet foo = Foo { bar };\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "redundant_pattern",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 242
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for patterns in the form `name @ _`.\n\n### Why is this bad?\nIt's almost always more readable to just use direct\nbindings.\n\n### Example\n```rust\n\n// Bad\nmatch v {\n    Some(x) => (),\n    y @ _ => (),\n}\n\n// Good\nmatch v {\n    Some(x) => (),\n    y => (),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "redundant_pattern_matching",
    "id_span": {
      "path": "src/matches.rs",
      "line": 483
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nLint for redundant pattern matching over `Result`, `Option`,\n`std::task::Poll` or `std::net::IpAddr`\n\n### Why is this bad?\nIt's more concise and clear to just use the proper\nutility function\n\n### Known problems\nThis will change the drop order for the matched type. Both `if let` and\n`while let` will drop the value at the end of the block, both `if` and `while` will drop the\nvalue before entering the block. For most types this change will not matter, but for a few\ntypes this will not be an acceptable change (e.g. locks). See the\n[reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\ndrop order.\n\n### Example\n```rust\nif let Ok(_) = Ok::<i32, i32>(42) {}\nif let Err(_) = Err::<i32, i32>(42) {}\nif let None = None::<()> {}\nif let Some(_) = Some(42) {}\nif let Poll::Pending = Poll::Pending::<()> {}\nif let Poll::Ready(_) = Poll::Ready(42) {}\nif let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\nif let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\nmatch Ok::<i32, i32>(42) {\n    Ok(_) => true,\n    Err(_) => false,\n};\n```\n\nThe more idiomatic use would be:\n\n```rust\nif Ok::<i32, i32>(42).is_ok() {}\nif Err::<i32, i32>(42).is_err() {}\nif None::<()>.is_none() {}\nif Some(42).is_some() {}\nif Poll::Pending::<()>.is_pending() {}\nif Poll::Ready(42).is_ready() {}\nif IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\nif IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\nOk::<i32, i32>(42).is_ok();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "redundant_pub_crate",
    "id_span": {
      "path": "src/redundant_pub_crate.rs",
      "line": 29
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for items declared `pub(crate)` that are not crate visible because they\nare inside a private module.\n\n### Why is this bad?\nWriting `pub(crate)` is misleading when it's redundant due to the parent\nmodule's visibility.\n\n### Example\n```rust\nmod internal {\n    pub(crate) fn internal_fn() { }\n}\n```\nThis function is not visible outside the module and it can be declared with `pub` or\nprivate visibility\n```rust\nmod internal {\n    pub fn internal_fn() { }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "redundant_slicing",
    "id_span": {
      "path": "src/redundant_slicing.rs",
      "line": 37
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for redundant slicing expressions which use the full range, and\ndo not change the type.\n\n### Why is this bad?\nIt unnecessarily adds complexity to the expression.\n\n### Known problems\nIf the type being sliced has an implementation of `Index<RangeFull>`\nthat actually changes anything then it can't be removed. However, this would be surprising\nto people reading the code and should have a note with it.\n\n### Example\n```rust\nfn get_slice(x: &[u32]) -> &[u32] {\n    &x[..]\n}\n```\nUse instead:\n```rust\nfn get_slice(x: &[u32]) -> &[u32] {\n    x\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "redundant_static_lifetimes",
    "id_span": {
      "path": "src/redundant_static_lifetimes.rs",
      "line": 30
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for constants and statics with an explicit `'static` lifetime.\n\n### Why is this bad?\nAdding `'static` to every reference can create very\ncomplicated types.\n\n### Example\n```rust\nconst FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\nstatic FOO: &'static [(&'static str, &'static str, fn(&Bar) -> bool)] =\n&[...]\n```\nThis code can be rewritten as\n```rust\n const FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n static FOO: &[(&str, &str, fn(&Bar) -> bool)] = &[...]\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "ref_binding_to_reference",
    "id_span": {
      "path": "src/needless_borrow.rs",
      "line": 66
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for `ref` bindings which create a reference to a reference.\n\n### Why is this bad?\nThe address-of operator at the use site is clearer about the need for a reference.\n\n### Example\n```rust\n// Bad\nlet x = Some(\"\");\nif let Some(ref x) = x {\n    // use `x` here\n}\n\n// Good\nlet x = Some(\"\");\nif let Some(x) = x {\n    // use `&x` here\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "ref_in_deref",
    "id_span": {
      "path": "src/reference.rs",
      "line": 128
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for references in expressions that use\nauto dereference.\n\n### Why is this bad?\nThe reference is a no-op and is automatically\ndereferenced by the compiler and makes the code less clear.\n\n### Example\n```rust\nstruct Point(u32, u32);\nlet point = Point(30, 20);\nlet x = (&point).0;\n```\nUse instead:\n```rust\nlet x = point.0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "ref_option_ref",
    "id_span": {
      "path": "src/ref_option_ref.rs",
      "line": 31
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `&Option<&T>`.\n\n### Why is this bad?\nSince `&` is Copy, it's useless to have a\nreference on `Option<&T>`.\n\n### Known problems\nIt may be irrelevant to use this lint on\npublic API code as it will make a breaking change to apply it.\n\n### Example\n```rust\nlet x: &Option<&u32> = &Some(&0u32);\n```\nUse instead:\n```rust\nlet x: Option<&u32> = Some(&0u32);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "regex_macro",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 150
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThe regex! macro does not exist anymore.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "repeat_once",
    "id_span": {
      "path": "src/repeat_once.rs",
      "line": 39
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `.repeat(1)` and suggest the following method for each types.\n- `.to_string()` for `str`\n- `.clone()` for `String`\n- `.to_vec()` for `slice`\n\nThe lint will evaluate constant expressions and values as arguments of `.repeat(..)` and emit a message if\nthey are equivalent to `1`. (Related discussion in [rust-clippy#7306](https://github.com/rust-lang/rust-clippy/issues/7306))\n\n### Why is this bad?\nFor example, `String.repeat(1)` is equivalent to `.clone()`. If cloning\nthe string is the intention behind this, `clone()` should be used.\n\n### Example\n```rust\nfn main() {\n    let x = String::from(\"hello world\").repeat(1);\n}\n```\nUse instead:\n```rust\nfn main() {\n    let x = String::from(\"hello world\").clone();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "replace_consts",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 140
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nAssociated-constants are now preferred.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "rest_pat_in_fully_bound_structs",
    "id_span": {
      "path": "src/matches.rs",
      "line": 428
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n\n### Why is this bad?\nCorrectness and readability. It's like having a wildcard pattern after\nmatching all enum variants explicitly.\n\n### Example\n```rust\nlet a = A { a: 5 };\n\n// Bad\nmatch a {\n    A { a: 5, .. } => {},\n    _ => {},\n}\n\n// Good\nmatch a {\n    A { a: 5 } => {},\n    _ => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "result_map_or_into_option",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 429
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.map_or(None, Some)`.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.ok()`.\n\n### Example\nBad:\n```rust\nassert_eq!(Some(1), r.map_or(None, Some));\n```\n\nGood:\n```rust\nassert_eq!(Some(1), r.ok());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "result_map_unit_fn",
    "id_span": {
      "path": "src/map_unit_fn.rs",
      "line": 90
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `result.map(f)` where f is a function\nor closure that returns the unit type `()`.\n\n### Why is this bad?\nReadability, this can be written more clearly with\nan if let statement\n\n### Example\n```rust\nlet x: Result<String, String> = do_stuff();\nx.map(log_err_msg);\nx.map(|msg| log_err_msg(format_msg(msg)));\n```\n\nThe correct use would be:\n\n```rust\nlet x: Result<String, String> = do_stuff();\nif let Ok(msg) = x {\n    log_err_msg(msg);\n};\nif let Ok(msg) = x {\n    log_err_msg(format_msg(msg));\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "result_unit_err",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 207
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for public functions that return a `Result`\nwith an `Err` type of `()`. It suggests using a custom type that\nimplements `std::error::Error`.\n\n### Why is this bad?\nUnit does not implement `Error` and carries no\nfurther information about what went wrong.\n\n### Known problems\nOf course, this lint assumes that `Result` is used\nfor a fallible operation (which is after all the intended use). However\ncode may opt to (mis)use it as a basic two-variant-enum. In that case,\nthe suggestion is misguided, and the code should use a custom enum\ninstead.\n\n### Examples\n```rust\npub fn read_u8() -> Result<u8, ()> { Err(()) }\n```\nshould become\n```rust\nuse std::fmt;\n\n#[derive(Debug)]\npub struct EndOfStream;\n\nimpl fmt::Display for EndOfStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"End of Stream\")\n    }\n}\n\nimpl std::error::Error for EndOfStream { }\n\npub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n```\n\nNote that there are crates that simplify creating the error type, e.g.\n[`thiserror`](https://docs.rs/thiserror).",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "reversed_empty_ranges",
    "id_span": {
      "path": "src/ranges.rs",
      "line": 135
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for range expressions `x..y` where both `x` and `y`\nare constant and `x` is greater or equal to `y`.\n\n### Why is this bad?\nEmpty ranges yield no values so iterating them is a no-op.\nMoreover, trying to use a reversed range to index a slice will panic at run-time.\n\n### Example\n```rust\nfn main() {\n    (10..=0).for_each(|x| println!(\"{}\", x));\n\n    let arr = [1, 2, 3, 4, 5];\n    let sub = &arr[3..1];\n}\n```\nUse instead:\n```rust\nfn main() {\n    (0..=10).rev().for_each(|x| println!(\"{}\", x));\n\n    let arr = [1, 2, 3, 4, 5];\n    let sub = &arr[1..3];\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "same_functions_in_if_condition",
    "id_span": {
      "path": "src/copies.rs",
      "line": 91
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for consecutive `if`s with the same function call.\n\n### Why is this bad?\nThis is probably a copy & paste error.\nDespite the fact that function can have side effects and `if` works as\nintended, such an approach is implicit and can be considered a \"code smell\".\n\n### Example\n```rust\nif foo() == bar {\n    …\n} else if foo() == bar {\n    …\n}\n```\n\nThis probably should be:\n```rust\nif foo() == bar {\n    …\n} else if foo() == baz {\n    …\n}\n```\n\nor if the original code was not a typo and called function mutates a state,\nconsider move the mutation out of the `if` condition to avoid similarity to\na copy & paste error:\n\n```rust\nlet first = foo();\nif first == bar {\n    …\n} else {\n    let second = foo();\n    if second == bar {\n    …\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "same_item_push",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 483
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks whether a for loop is being used to push a constant\nvalue into a Vec.\n\n### Why is this bad?\nThis kind of operation can be expressed more succinctly with\n`vec![item;SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\nhave better performance.\n\n### Example\n```rust\nlet item1 = 2;\nlet item2 = 3;\nlet mut vec: Vec<u8> = Vec::new();\nfor _ in 0..20 {\n   vec.push(item1);\n}\nfor _ in 0..30 {\n    vec.push(item2);\n}\n```\ncould be written as\n```rust\nlet item1 = 2;\nlet item2 = 3;\nlet mut vec: Vec<u8> = vec![item1; 20];\nvec.resize(20 + 30, item2);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "same_name_method",
    "id_span": {
      "path": "src/same_name_method.rs",
      "line": 36
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nIt lints if a struct has two method with same time:\none from a trait, another not from trait.\n\n### Why is this bad?\nConfusing.\n\n### Example\n```rust\ntrait T {\n    fn foo(&self) {}\n}\n\nstruct S;\n\nimpl T for S {\n    fn foo(&self) {}\n}\n\nimpl S {\n    fn foo(&self) {}\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "search_is_some",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 655
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for an iterator or string search (such as `find()`,\n`position()`, or `rposition()`) followed by a call to `is_some()` or `is_none()`.\n\n### Why is this bad?\nReadability, this can be written more concisely as:\n* `_.any(_)`, or `_.contains(_)` for `is_some()`,\n* `!_.any(_)`, or `!_.contains(_)` for `is_none()`.\n\n### Example\n```rust\nlet vec = vec![1];\nvec.iter().find(|x| **x == 0).is_some();\n\nlet _ = \"hello world\".find(\"world\").is_none();\n```\nCould be written as\n```rust\nlet vec = vec![1];\nvec.iter().any(|x| *x == 0);\n\nlet _ = !\"hello world\".contains(\"world\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "self_assignment",
    "id_span": {
      "path": "src/self_assignment.rs",
      "line": 33
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for explicit self-assignments.\n\n### Why is this bad?\nSelf-assignments are redundant and unlikely to be\nintentional.\n\n### Known problems\nIf expression contains any deref coercions or\nindexing operations they are assumed not to have any side effects.\n\n### Example\n```rust\nstruct Event {\n    id: usize,\n    x: i32,\n    y: i32,\n}\n\nfn copy_position(a: &mut Event, b: &Event) {\n    a.x = b.x;\n    a.y = a.y;\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "self_named_constructors",
    "id_span": {
      "path": "src/self_named_constructors.rs",
      "line": 35
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nWarns when constructors have the same name as their types.\n\n### Why is this bad?\nRepeating the name of the type is redundant.\n\n### Example\n```rust\nstruct Foo {}\n\nimpl Foo {\n    pub fn foo() -> Foo {\n        Foo {}\n    }\n}\n```\nUse instead:\n```rust\nstruct Foo {}\n\nimpl Foo {\n    pub fn new() -> Foo {\n        Foo {}\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "self_named_module_files",
    "id_span": {
      "path": "src/module_style.rs",
      "line": 64
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks that module layout uses only mod.rs files.\n\n### Why is this bad?\nHaving multiple module layout styles in a project can be confusing.\n\n### Example\n```text\nsrc/\n  stuff/\n    stuff_files.rs\n  stuff.rs\n  lib.rs\n```\nUse instead:\n```text\nsrc/\n  stuff/\n    stuff_files.rs\n    mod.rs\n  lib.rs\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "semicolon_if_nothing_returned",
    "id_span": {
      "path": "src/semicolon_if_nothing_returned.rs",
      "line": 32
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nLooks for blocks of expressions and fires if the last expression returns\n`()` but is not followed by a semicolon.\n\n### Why is this bad?\nThe semicolon might be optional but when extending the block with new\ncode, it doesn't require a change in previous last line.\n\n### Example\n```rust\nfn main() {\n    println!(\"Hello world\")\n}\n```\nUse instead:\n```rust\nfn main() {\n    println!(\"Hello world\");\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "separated_literal_suffix",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 154
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nWarns if literal suffixes are separated by an underscore.\nTo enforce separated literal suffix style,\nsee the `unseparated_literal_suffix` lint.\n\n### Why is this bad?\nSuffix style should be consistent.\n\n### Example\n```rust\n// Bad\nlet y = 123832_i32;\n\n// Good\nlet y = 123832i32;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "serde_api_misuse",
    "id_span": {
      "path": "src/serde_api.rs",
      "line": 18
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for mis-uses of the serde API.\n\n### Why is this bad?\nSerde is very finnicky about how its API should be\nused, but the type system can't be used to enforce it (yet?).\n\n### Example\nImplementing `Visitor::visit_string` but not\n`Visitor::visit_str`.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "shadow_reuse",
    "id_span": {
      "path": "src/shadow.rs",
      "line": 58
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for bindings that shadow other bindings already in\nscope, while reusing the original value.\n\n### Why is this bad?\nNot too much, in fact it's a common pattern in Rust\ncode. Still, some argue that name shadowing like this hurts readability,\nbecause a value may be bound to different things depending on position in\nthe code.\n\n### Example\n```rust\nlet x = 2;\nlet x = x + 1;\n```\nuse different variable name:\n```rust\nlet x = 2;\nlet y = x + 1;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "shadow_same",
    "id_span": {
      "path": "src/shadow.rs",
      "line": 32
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for bindings that shadow other bindings already in\nscope, while just changing reference level or mutability.\n\n### Why is this bad?\nNot much, in fact it's a very common pattern in Rust\ncode. Still, some may opt to avoid it in their code base, they can set this\nlint to `Warn`.\n\n### Example\n```rust\n// Bad\nlet x = &x;\n\n// Good\nlet y = &x; // use different variable name\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "shadow_unrelated",
    "id_span": {
      "path": "src/shadow.rs",
      "line": 87
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for bindings that shadow other bindings already in\nscope, either without an initialization or with one that does not even use\nthe original value.\n\n### Why is this bad?\nName shadowing can hurt readability, especially in\nlarge code bases, because it is easy to lose track of the active binding at\nany place in the code. This can be alleviated by either giving more specific\nnames to bindings or introducing more scopes to contain the bindings.\n\n### Example\n```rust\nlet x = y;\n\n// Bad\nlet x = z; // shadows the earlier binding\n\n// Good\nlet w = z; // use different variable name\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "short_circuit_statement",
    "id_span": {
      "path": "src/misc.rs",
      "line": 210
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of short circuit boolean conditions as\na\nstatement.\n\n### Why is this bad?\nUsing a short circuit boolean condition as a statement\nmay hide the fact that the second part is executed or not depending on the\noutcome of the first part.\n\n### Example\n```rust\nf() && g(); // We should write `if f() { g(); }`.\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "should_assert_eq",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 24
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis used to check for `assert!(a == b)` and recommend\nreplacement with `assert_eq!(a, b)`, but this is no longer needed after RFC 2011.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "should_implement_trait",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 240
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for methods that should live in a trait\nimplementation of a `std` trait (see [llogiq's blog\npost](http://llogiq.github.io/2015/07/30/traits.html) for further\ninformation) instead of an inherent implementation.\n\n### Why is this bad?\nImplementing the traits improve ergonomics for users of\nthe code, often with very little cost. Also people seeing a `mul(...)`\nmethod\nmay expect `*` to work equally, so you should have good reason to disappoint\nthem.\n\n### Example\n```rust\nstruct X;\nimpl X {\n    fn add(&self, other: &X) -> X {\n        // ..\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "similar_names",
    "id_span": {
      "path": "src/non_expressive_names.rs",
      "line": 27
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for names that are very similar and thus confusing.\n\n### Why is this bad?\nIt's hard to distinguish between names that differ only\nby a single character.\n\n### Example\n```rust\nlet checked_exp = something;\nlet checked_expr = something_else;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "single_char_add_str",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1491
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nWarns when using `push_str`/`insert_str` with a single-character string literal\nwhere `push`/`insert` with a `char` would work fine.\n\n### Why is this bad?\nIt's less clear that we are pushing a single character.\n\n### Example\n```rust\nlet mut string = String::new();\nstring.insert_str(0, \"R\");\nstring.push_str(\"R\");\n```\nCould be written as\n```rust\nlet mut string = String::new();\nstring.insert(0, 'R');\nstring.push('R');\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "single_char_pattern",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 925
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for string methods that receive a single-character\n`str` as an argument, e.g., `_.split(\"x\")`.\n\n### Why is this bad?\nPerforming these methods using a `char` is faster than\nusing a `str`.\n\n### Known problems\nDoes not catch multi-byte unicode characters.\n\n### Example\n```rust\n// Bad\n_.split(\"x\");\n\n// Good\n_.split('x');",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "single_component_path_imports",
    "id_span": {
      "path": "src/single_component_path_imports.rs",
      "line": 31
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecking for imports with single component use path.\n\n### Why is this bad?\nImport with single component use path such as `use cratename;`\nis not necessary, and thus should be removed.\n\n### Example\n```rust\nuse regex;\n\nfn main() {\n    regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n}\n```\nBetter as\n```rust\nfn main() {\n    regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "single_element_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 509
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks whether a for loop has a single element.\n\n### Why is this bad?\nThere is no reason to have a loop of a\nsingle element.\n\n### Example\n```rust\nlet item1 = 2;\nfor item in &[item1] {\n    println!(\"{}\", item);\n}\n```\ncould be written as\n```rust\nlet item1 = 2;\nlet item = &item1;\nprintln!(\"{}\", item);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "single_match",
    "id_span": {
      "path": "src/matches.rs",
      "line": 63
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for matches with a single arm where an `if let`\nwill usually suffice.\n\n### Why is this bad?\nJust readability – `if let` nests less than a `match`.\n\n### Example\n```rust\n// Bad\nmatch x {\n    Some(ref foo) => bar(foo),\n    _ => (),\n}\n\n// Good\nif let Some(ref foo) = x {\n    bar(foo);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "single_match_else",
    "id_span": {
      "path": "src/matches.rs",
      "line": 104
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for matches with two arms where an `if let else` will\nusually suffice.\n\n### Why is this bad?\nJust readability – `if let` nests less than a `match`.\n\n### Known problems\nPersonal style preferences may differ.\n\n### Example\nUsing `match`:\n\n```rust\nmatch x {\n    Some(ref foo) => bar(foo),\n    _ => bar(&other_ref),\n}\n```\n\nUsing `if let` with `else`:\n\n```rust\nif let Some(ref foo) = x {\n    bar(foo);\n} else {\n    bar(&other_ref);\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "size_of_in_element_count",
    "id_span": {
      "path": "src/size_of_in_element_count.rs",
      "line": 32
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nDetects expressions where\n`size_of::<T>` or `size_of_val::<T>` is used as a\ncount of elements of type `T`\n\n### Why is this bad?\nThese functions expect a count\nof `T` and not a number of bytes\n\n### Example\n```rust\nconst SIZE: usize = 128;\nlet x = [2u8; SIZE];\nlet mut y = [2u8; SIZE];\nunsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "skip_while_next",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 507
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `_.skip_while(condition).next()`.\n\n### Why is this bad?\nReadability, this can be written more concisely as\n`_.find(!condition)`.\n\n### Example\n```rust\nvec.iter().skip_while(|x| **x == 0).next();\n```\nCould be written as\n```rust\nvec.iter().find(|x| **x != 0);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "slow_vector_initialization",
    "id_span": {
      "path": "src/slow_vector_initialization.rs",
      "line": 39
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks slow zero-filled vector initialization\n\n### Why is this bad?\nThese structures are non-idiomatic and less efficient than simply using\n`vec![0; len]`.\n\n### Example\n```rust\n\n// Bad\nlet mut vec1 = Vec::with_capacity(len);\nvec1.resize(len, 0);\n\nlet mut vec2 = Vec::with_capacity(len);\nvec2.extend(repeat(0).take(len));\n\n// Good\nlet mut vec1 = vec![0; len];\nlet mut vec2 = vec![0; len];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "stable_sort_primitive",
    "id_span": {
      "path": "src/stable_sort_primitive.rs",
      "line": 31
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nWhen sorting primitive values (integers, bools, chars, as well\nas arrays, slices, and tuples of such items), it is better to\nuse an unstable sort than a stable sort.\n\n### Why is this bad?\nUsing a stable sort consumes more memory and cpu cycles. Because\nvalues which compare equal are identical, preserving their\nrelative order (the guarantee that a stable sort provides) means\nnothing, while the extra costs still apply.\n\n### Example\n```rust\nlet mut vec = vec![2, 1, 3];\nvec.sort();\n```\nUse instead:\n```rust\nlet mut vec = vec![2, 1, 3];\nvec.sort_unstable();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "str_to_string",
    "id_span": {
      "path": "src/strings.rs",
      "line": 374
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nThis lint checks for `.to_string()` method calls on values of type `&str`.\n\n### Why is this bad?\nThe `to_string` method is also used on other types to convert them to a string.\nWhen called on a `&str` it turns the `&str` into the owned variant `String`, which can be better\nexpressed with `.to_owned()`.\n\n### Example\n```rust\n// example code where clippy issues a warning\nlet _ = \"str\".to_string();\n```\nUse instead:\n```rust\n// example code which does not raise clippy warning\nlet _ = \"str\".to_owned();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "string_add",
    "id_span": {
      "path": "src/strings.rs",
      "line": 61
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for all instances of `x + _` where `x` is of type\n`String`, but only if [`string_add_assign`](#string_add_assign) does *not*\nmatch.\n\n### Why is this bad?\nIt's not bad in and of itself. However, this particular\n`Add` implementation is asymmetric (the other operand need not be `String`,\nbut `x` does), while addition as mathematically defined is symmetric, also\nthe `String::push_str(_)` function is a perfectly good replacement.\nTherefore, some dislike it and wish not to have it in their code.\n\nThat said, other people think that string addition, having a long tradition\nin other languages is actually fine, which is why we decided to make this\nparticular lint `allow` by default.\n\n### Example\n```rust\nlet x = \"Hello\".to_owned();\nx + \", World\";\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "string_add_assign",
    "id_span": {
      "path": "src/strings.rs",
      "line": 34
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for string appends of the form `x = x + y` (without\n`let`!).\n\n### Why is this bad?\nIt's not really bad, but some people think that the\n`.push_str(_)` method is more readable.\n\n### Example\n```rust\nlet mut x = \"Hello\".to_owned();\nx = x + \", World\";\n\n// More readable\nx += \", World\";\nx.push_str(\", World\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "string_extend_chars",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1130
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of `.extend(s.chars())` where s is a\n`&str` or `String`.\n\n### Why is this bad?\n`.push_str(s)` is clearer\n\n### Example\n```rust\nlet abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.extend(abc.chars());\ns.extend(def.chars());\n```\nThe correct use would be:\n```rust\nlet abc = \"abc\";\nlet def = String::from(\"def\");\nlet mut s = String::new();\ns.push_str(abc);\ns.push_str(&def);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "string_from_utf8_as_bytes",
    "id_span": {
      "path": "src/strings.rs",
      "line": 230
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nCheck if the string is transformed to byte array and casted back to string.\n\n### Why is this bad?\nIt's unnecessary, the string can be used directly.\n\n### Example\n```rust\nlet _ = std::str::from_utf8(&\"Hello World!\".as_bytes()[6..11]).unwrap();\n```\ncould be written as\n```rust\nlet _ = &\"Hello World!\"[6..11];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "string_lit_as_bytes",
    "id_span": {
      "path": "src/strings.rs",
      "line": 105
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for the `as_bytes` method called on string literals\nthat contain only ASCII characters.\n\n### Why is this bad?\nByte string literals (e.g., `b\"foo\"`) can be used\ninstead. They are shorter but less discoverable than `as_bytes()`.\n\n### Known problems\n`\"str\".as_bytes()` and the suggested replacement of `b\"str\"` are not\nequivalent because they have different types. The former is `&[u8]`\nwhile the latter is `&[u8; 3]`. That means in general they will have a\ndifferent set of methods and different trait implementations.\n\n```compile_fail\nfn f(v: Vec<u8>) {}\n\nf(\"...\".as_bytes().to_owned()); // works\nf(b\"...\".to_owned()); // does not work, because arg is [u8; 3] not Vec<u8>\n\nfn g(r: impl std::io::Read) {}\n\ng(\"...\".as_bytes()); // works\ng(b\"...\"); // does not work\n```\n\nThe actual equivalent of `\"str\".as_bytes()` with the same type is not\n`b\"str\"` but `&b\"str\"[..]`, which is a great deal of punctuation and not\nmore readable than a function call.\n\n### Example\n```rust\n// Bad\nlet bs = \"a byte string\".as_bytes();\n\n// Good\nlet bs = b\"a byte string\";\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "string_slice",
    "id_span": {
      "path": "src/strings.rs",
      "line": 128
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for slice operations on strings\n\n### Why is this bad?\nUTF-8 characters span multiple bytes, and it is easy to inadvertently confuse character\ncounts and string indices. This may lead to panics, and should warrant some test cases\ncontaining wide UTF-8 characters. This lint is most useful in code that should avoid\npanics at all costs.\n\n### Known problems\nProbably lots of false positives. If an index comes from a known valid position (e.g.\nobtained via `char_indices` over the same string), it is totally OK.\n\n# Example\n```rust\n&\"Ölkanne\"[1..];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "string_to_string",
    "id_span": {
      "path": "src/strings.rs",
      "line": 423
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nThis lint checks for `.to_string()` method calls on values of type `String`.\n\n### Why is this bad?\nThe `to_string` method is also used on other types to convert them to a string.\nWhen called on a `String` it only clones the `String`, which can be better expressed with `.clone()`.\n\n### Example\n```rust\n// example code where clippy issues a warning\nlet msg = String::from(\"Hello World\");\nlet _ = msg.to_string();\n```\nUse instead:\n```rust\n// example code which does not raise clippy warning\nlet msg = String::from(\"Hello World\");\nlet _ = msg.clone();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "strlen_on_c_strings",
    "id_span": {
      "path": "src/strlen_on_c_strings.rs",
      "line": 34
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `libc::strlen` on a `CString` or `CStr` value,\nand suggest calling `as_bytes().len()` or `to_bytes().len()` respectively instead.\n\n### Why is this bad?\nThis avoids calling an unsafe `libc` function.\nCurrently, it also avoids calculating the length.\n\n### Example\n```rust\nuse std::ffi::CString;\nlet cstring = CString::new(\"foo\").expect(\"CString::new failed\");\nlet len = unsafe { libc::strlen(cstring.as_ptr()) };\n```\nUse instead:\n```rust\nuse std::ffi::CString;\nlet cstring = CString::new(\"foo\").expect(\"CString::new failed\");\nlet len = cstring.as_bytes().len();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "struct_excessive_bools",
    "id_span": {
      "path": "src/excessive_bools.rs",
      "line": 41
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for excessive\nuse of bools in structs.\n\n### Why is this bad?\nExcessive bools in a struct\nis often a sign that it's used as a state machine,\nwhich is much better implemented as an enum.\nIf it's not the case, excessive bools usually benefit\nfrom refactoring into two-variant enums for better\nreadability and API.\n\n### Example\nBad:\n```rust\nstruct S {\n    is_pending: bool,\n    is_processing: bool,\n    is_finished: bool,\n}\n```\n\nGood:\n```rust\nenum S {\n    Pending,\n    Processing,\n    Finished,\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `max-struct-bools`: `u64`: The maximum number of bool fields a struct can have (defaults to `3`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suboptimal_flops",
    "id_span": {
      "path": "src/floating_point_arithmetic.rs",
      "line": 102
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nLooks for floating-point expressions that\ncan be expressed using built-in methods to improve both\naccuracy and performance.\n\n### Why is this bad?\nNegatively impacts accuracy and performance.\n\n### Example\n```rust\nuse std::f32::consts::E;\n\nlet a = 3f32;\nlet _ = (2f32).powf(a);\nlet _ = E.powf(a);\nlet _ = a.powf(1.0 / 2.0);\nlet _ = a.log(2.0);\nlet _ = a.log(10.0);\nlet _ = a.log(E);\nlet _ = a.powf(2.0);\nlet _ = a * 2.0 + 4.0;\nlet _ = if a < 0.0 {\n    -a\n} else {\n    a\n};\nlet _ = if a < 0.0 {\n    a\n} else {\n    -a\n};\n```\n\nis better expressed as\n\n```rust\nuse std::f32::consts::E;\n\nlet a = 3f32;\nlet _ = a.exp2();\nlet _ = a.exp();\nlet _ = a.sqrt();\nlet _ = a.log2();\nlet _ = a.log10();\nlet _ = a.ln();\nlet _ = a.powi(2);\nlet _ = a.mul_add(2.0, 4.0);\nlet _ = a.abs();\nlet _ = -a.abs();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "suspicious_arithmetic_impl",
    "id_span": {
      "path": "src/suspicious_trait_impl.rs",
      "line": 28
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nLints for suspicious operations in impls of arithmetic operators, e.g.\nsubtracting elements in an Add impl.\n\n### Why is this bad?\nThis is probably a typo or copy-and-paste error and not intended.\n\n### Example\n```rust\nimpl Add for Foo {\n    type Output = Foo;\n\n    fn add(self, other: Foo) -> Foo {\n        Foo(self.0 - other.0)\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_assignment_formatting",
    "id_span": {
      "path": "src/formatting.rs",
      "line": 24
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of the non-existent `=*`, `=!` and `=-`\noperators.\n\n### Why is this bad?\nThis is either a typo of `*=`, `!=` or `-=` or\nconfusing.\n\n### Example\n```rust\na =- 42; // confusing, should it be `a -= 42` or `a = -42`?\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_else_formatting",
    "id_span": {
      "path": "src/formatting.rs",
      "line": 82
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for formatting of `else`. It lints if the `else`\nis followed immediately by a newline or the `else` seems to be missing.\n\n### Why is this bad?\nThis is probably some refactoring remnant, even if the\ncode is correct, it might look confusing.\n\n### Example\n```rust\nif foo {\n} { // looks like an `else` is missing here\n}\n\nif foo {\n} if bar { // looks like an `else` is missing here\n}\n\nif foo {\n} else\n\n{ // this is the `else` block of the previous `if`, but should it be?\n}\n\nif foo {\n} else\n\nif bar { // this is the `else` block of the previous `if`, but should it be?\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_map",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1295
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks for calls to `map` followed by a `count`.\n\n### Why is this bad?\nIt looks suspicious. Maybe `map` was confused with `filter`.\nIf the `map` call is intentional, this should be rewritten\nusing `inspect`. Or, if you intend to drive the iterator to\ncompletion, you can just use `for_each` instead.\n\n### Example\n```rust\nlet _ = (0..3).map(|x| x + 2).count();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_op_assign_impl",
    "id_span": {
      "path": "src/suspicious_trait_impl.rs",
      "line": 49
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nLints for suspicious operations in impls of OpAssign, e.g.\nsubtracting elements in an AddAssign impl.\n\n### Why is this bad?\nThis is probably a typo or copy-and-paste error and not intended.\n\n### Example\n```rust\nimpl AddAssign for Foo {\n    fn add_assign(&mut self, other: Foo) {\n        *self = *self - other;\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_operation_groupings",
    "id_span": {
      "path": "src/suspicious_operation_groupings.rs",
      "line": 62
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for unlikely usages of binary operators that are almost\ncertainly typos and/or copy/paste errors, given the other usages\nof binary operators nearby.\n\n### Why is this bad?\nThey are probably bugs and if they aren't then they look like bugs\nand you should add a comment explaining why you are doing such an\nodd set of operations.\n\n### Known problems\nThere may be some false positives if you are trying to do something\nunusual that happens to look like a typo.\n\n### Example\n```rust\nstruct Vec3 {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nimpl Eq for Vec3 {}\n\nimpl PartialEq for Vec3 {\n    fn eq(&self, other: &Self) -> bool {\n        // This should trigger the lint because `self.x` is compared to `other.y`\n        self.x == other.y && self.y == other.y && self.z == other.z\n    }\n}\n```\nUse instead:\n```rust\n// same as above except:\nimpl PartialEq for Vec3 {\n    fn eq(&self, other: &Self) -> bool {\n        // Note we now compare other.x to self.x\n        self.x == other.x && self.y == other.y && self.z == other.z\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_splitn",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1754
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for calls to [`splitn`]\n(https://doc.rust-lang.org/std/primitive.str.html#method.splitn) and\nrelated functions with either zero or one splits.\n\n### Why is this bad?\nThese calls don't actually split the value and are\nlikely to be intended as a different number.\n\n### Example\n```rust\n// Bad\nlet s = \"\";\nfor x in s.splitn(1, \":\") {\n    // use x\n}\n\n// Good\nlet s = \"\";\nfor x in s.splitn(2, \":\") {\n    // use x\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "suspicious_unary_op_formatting",
    "id_span": {
      "path": "src/formatting.rs",
      "line": 46
    },
    "group": "suspicious",
    "level": "warn",
    "docs": " ### What it does\nChecks the formatting of a unary operator on the right hand side\nof a binary operator. It lints if there is no space between the binary and unary operators,\nbut there is a space between the unary and its operand.\n\n### Why is this bad?\nThis is either a typo in the binary operator or confusing.\n\n### Example\n```rust\nif foo <- 30 { // this should be `foo < -30` but looks like a different operator\n}\n\nif foo &&! bar { // this should be `foo && !bar` but looks like a different operator\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "tabs_in_doc_comments",
    "id_span": {
      "path": "src/tabs_in_doc_comments.rs",
      "line": 54
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks doc comments for usage of tab characters.\n\n### Why is this bad?\nThe rust style-guide promotes spaces instead of tabs for indentation.\nTo keep a consistent view on the source, also doc comments should not have tabs.\nAlso, explaining ascii-diagrams containing tabs can get displayed incorrectly when the\ndisplay settings of the author and reader differ.\n\n### Example\n```rust\n///\n/// Struct to hold two strings:\n/// \t- first\t\tone\n/// \t- second\tone\npub struct DoubleString {\n   ///\n   /// \t- First String:\n   /// \t\t- needs to be inside here\n   first_string: String,\n   ///\n   /// \t- Second String:\n   /// \t\t- needs to be inside here\n   second_string: String,\n}\n```\n\nWill be converted to:\n```rust\n///\n/// Struct to hold two strings:\n///     - first        one\n///     - second    one\npub struct DoubleString {\n   ///\n   ///     - First String:\n   ///         - needs to be inside here\n   first_string: String,\n   ///\n   ///     - Second String:\n   ///         - needs to be inside here\n   second_string: String,\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "temporary_assignment",
    "id_span": {
      "path": "src/temporary_assignment.rs",
      "line": 20
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for construction of a structure or tuple just to\nassign a value in it.\n\n### Why is this bad?\nReadability. If the structure is only created to be\nupdated, why not write the structure you want in the first place?\n\n### Example\n```rust\n(0, 0).0 = 1\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "to_digit_is_some",
    "id_span": {
      "path": "src/to_digit_is_some.rs",
      "line": 31
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `.to_digit(..).is_some()` on `char`s.\n\n### Why is this bad?\nThis is a convoluted way of checking if a `char` is a digit. It's\nmore straight forward to use the dedicated `is_digit` method.\n\n### Example\n```rust\nlet is_digit = c.to_digit(radix).is_some();\n```\ncan be written as:\n```rust\nlet is_digit = c.is_digit(radix);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "to_string_in_display",
    "id_span": {
      "path": "src/to_string_in_display.rs",
      "line": 42
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for uses of `to_string()` in `Display` traits.\n\n### Why is this bad?\nUsually `to_string` is implemented indirectly\nvia `Display`. Hence using it while implementing `Display` would\nlead to infinite recursion.\n\n### Example\n\n```rust\nuse std::fmt;\n\nstruct Structure(i32);\nimpl fmt::Display for Structure {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.to_string())\n    }\n}\n\n```\nUse instead:\n```rust\nuse std::fmt;\n\nstruct Structure(i32);\nimpl fmt::Display for Structure {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "to_string_in_format_args",
    "id_span": {
      "path": "src/format_args.rs",
      "line": 59
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for [`ToString::to_string`](https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string)\napplied to a type that implements [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html)\nin a macro that does formatting.\n\n### Why is this bad?\nSince the type implements `Display`, the use of `to_string` is\nunnecessary.\n\n### Example\n```rust\nprintln!(\"error: something failed at {}\", Location::caller().to_string());\n```\nUse instead:\n```rust\nprintln!(\"error: something failed at {}\", Location::caller());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "todo",
    "id_span": {
      "path": "src/panic_unimplemented.rs",
      "line": 52
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `todo!`.\n\n### Why is this bad?\nThis macro should not be present in production code\n\n### Example\n```rust\ntodo!();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "too_many_arguments",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 29
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for functions with too many parameters.\n\n### Why is this bad?\nFunctions with lots of parameters are considered bad\nstyle and reduce readability (“what does the 5th parameter mean?”). Consider\ngrouping some parameters into a new type.\n\n### Example\n```rust\nfn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n    // ..\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `too-many-arguments-threshold`: `u64`: The maximum number of argument a function or method can have (defaults to `7`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "too_many_lines",
    "id_span": {
      "path": "src/functions/mod.rs",
      "line": 52
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for functions with a large amount of lines.\n\n### Why is this bad?\nFunctions with a lot of lines are harder to understand\ndue to having to look at a larger amount of code to understand what the\nfunction is doing. Consider splitting the body of the function into\nmultiple functions.\n\n### Example\n```rust\nfn im_too_long() {\n    println!(\"\");\n    // ... 100 more LoC\n    println!(\"\");\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `too-many-lines-threshold`: `u64`: The maximum number of lines a function or method can have (defaults to `100`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "toplevel_ref_arg",
    "id_span": {
      "path": "src/misc.rs",
      "line": 59
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for function arguments and let bindings denoted as\n`ref`.\n\n### Why is this bad?\nThe `ref` declaration makes the function take an owned\nvalue, but turns the argument into a reference (which means that the value\nis destroyed when exiting the function). This adds not much value: either\ntake a reference type, or take an owned value and create references in the\nbody.\n\nFor let bindings, `let x = &foo;` is preferred over `let ref x = foo`. The\ntype of `x` is more obvious with the former.\n\n### Known problems\nIf the argument is dereferenced within the function,\nremoving the `ref` will lead to errors. This can be fixed by removing the\ndereferences, e.g., changing `*x` to `x` within the function.\n\n### Example\n```rust\n// Bad\nfn foo(ref x: u8) -> bool {\n    true\n}\n\n// Good\nfn foo(x: &u8) -> bool {\n    true\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "trailing_empty_array",
    "id_span": {
      "path": "src/trailing_empty_array.rs",
      "line": 31
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nDisplays a warning when a struct with a trailing zero-sized array is declared without a `repr` attribute.\n\n### Why is this bad?\nZero-sized arrays aren't very useful in Rust itself, so such a struct is likely being created to pass to C code or in some other situation where control over memory layout matters (for example, in conjuction with manual allocation to make it easy to compute the offset of the array). Either way, `#[repr(C)]` (or another `repr` attribute) is needed.\n\n### Example\n```rust\nstruct RarelyUseful {\n    some_field: u32,\n    last: [u32; 0],\n}\n```\n\nUse instead:\n```rust\n#[repr(C)]\nstruct MoreOftenUseful {\n    some_field: usize,\n    last: [u32; 0],\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "trait_duplication_in_bounds",
    "id_span": {
      "path": "src/trait_bounds.rs",
      "line": 60
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for cases where generics are being used and multiple\nsyntax specifications for trait bounds are used simultaneously.\n\n### Why is this bad?\nDuplicate bounds makes the code\nless readable than specifing them only once.\n\n### Example\n```rust\nfn func<T: Clone + Default>(arg: T) where T: Clone + Default {}\n```\n\nCould be written as:\n\n```rust\nfn func<T: Clone + Default>(arg: T) {}\n```\nor\n\n```rust\nfn func<T>(arg: T) where T: Clone + Default {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "transmute_bytes_to_str",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 194
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from a `&[u8]` to a `&str`.\n\n### Why is this bad?\nNot every byte slice is a valid UTF-8 string.\n\n### Known problems\n- [`from_utf8`] which this lint suggests using is slower than `transmute`\nas it needs to validate the input.\nIf you are certain that the input is always a valid UTF-8,\nuse [`from_utf8_unchecked`] which is as fast as `transmute`\nbut has a semantically meaningful name.\n- You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n\n[`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n[`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n\n### Example\n```rust\nlet b: &[u8] = &[1_u8, 2_u8];\nunsafe {\n    let _: &str = std::mem::transmute(b); // where b: &[u8]\n}\n\n// should be:\nlet _ = std::str::from_utf8(b).unwrap();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_float_to_int",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 260
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from a float to an integer.\n\n### Why is this bad?\nTransmutes are dangerous and error-prone, whereas `to_bits` is intuitive\nand safe.\n\n### Example\n```rust\nunsafe {\n    let _: u32 = std::mem::transmute(1f32);\n}\n\n// should be:\nlet _: u32 = 1f32.to_bits();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_int_to_bool",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 216
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from an integer to a `bool`.\n\n### Why is this bad?\nThis might result in an invalid in-memory representation of a `bool`.\n\n### Example\n```rust\nlet x = 1_u8;\nunsafe {\n    let _: bool = std::mem::transmute(x); // where x: u8\n}\n\n// should be:\nlet _: bool = x != 0;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_int_to_char",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 161
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from an integer to a `char`.\n\n### Why is this bad?\nNot every integer is a Unicode scalar value.\n\n### Known problems\n- [`from_u32`] which this lint suggests using is slower than `transmute`\nas it needs to validate the input.\nIf you are certain that the input is always a valid Unicode scalar value,\nuse [`from_u32_unchecked`] which is as fast as `transmute`\nbut has a semantically meaningful name.\n- You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n\n[`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n[`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n\n### Example\n```rust\nlet x = 1_u32;\nunsafe {\n    let _: char = std::mem::transmute(x); // where x: u32\n}\n\n// should be:\nlet _ = std::char::from_u32(x).unwrap();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_int_to_float",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 238
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from an integer to a float.\n\n### Why is this bad?\nTransmutes are dangerous and error-prone, whereas `from_bits` is intuitive\nand safe.\n\n### Example\n```rust\nunsafe {\n    let _: f32 = std::mem::transmute(1_u32); // where x: u32\n}\n\n// should be:\nlet _: f32 = f32::from_bits(1_u32);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_num_to_bytes",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 282
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from a number to an array of `u8`\n\n### Why this is bad?\nTransmutes are dangerous and error-prone, whereas `to_ne_bytes`\nis intuitive and safe.\n\n### Example\n```rust\nunsafe {\n    let x: [u8; 8] = std::mem::transmute(1i64);\n}\n\n// should be\nlet x: [u8; 8] = 0i64.to_ne_bytes();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_ptr_to_ptr",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 309
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for transmutes from a pointer to a pointer, or\nfrom a reference to a reference.\n\n### Why is this bad?\nTransmutes are dangerous, and these can instead be\nwritten as casts.\n\n### Example\n```rust\nlet ptr = &1u32 as *const u32;\nunsafe {\n    // pointer-to-pointer transmute\n    let _: *const f32 = std::mem::transmute(ptr);\n    // ref-ref transmute\n    let _: &f32 = std::mem::transmute(&1u32);\n}\n// These can be respectively written:\nlet _ = ptr as *const f32;\nlet _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmute_ptr_to_ref",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 128
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes from a pointer to a reference.\n\n### Why is this bad?\nThis can always be rewritten with `&` and `*`.\n\n### Known problems\n- `mem::transmute` in statics and constants is stable from Rust 1.46.0,\nwhile dereferencing raw pointer is not stable yet.\nIf you need to do this in those places,\nyou would have to use `transmute` instead.\n\n### Example\n```rust\nunsafe {\n    let _: &T = std::mem::transmute(p); // where p: *const T\n}\n\n// can be written:\nlet _: &T = &*p;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "transmutes_expressible_as_ptr_casts",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 83
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for transmutes that could be a pointer cast.\n\n### Why is this bad?\nReadability. The code tricks people into thinking that\nsomething complex is going on.\n\n### Example\n\n```rust\nunsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n```\nUse instead:\n```rust\np as *const [u16];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "transmuting_null",
    "id_span": {
      "path": "src/transmuting_null.rs",
      "line": 28
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for transmute calls which would receive a null pointer.\n\n### Why is this bad?\nTransmuting a null pointer is undefined behavior.\n\n### Known problems\nNot all cases can be detected at the moment of this writing.\nFor example, variables which hold a null pointer and are then fed to a `transmute`\ncall, aren't detectable yet.\n\n### Example\n```rust\nlet null_ref: &u64 = unsafe { std::mem::transmute(0 as *const u64) };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "trivial_regex",
    "id_span": {
      "path": "src/regex.rs",
      "line": 49
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for trivial [regex](https://crates.io/crates/regex)\ncreation (with `Regex::new`, `RegexBuilder::new`, or `RegexSet::new`).\n\n### Why is this bad?\nMatching the regex can likely be replaced by `==` or\n`str::starts_with`, `str::ends_with` or `std::contains` or other `str`\nmethods.\n\n### Known problems\nIf the same regex is going to be applied to multiple\ninputs, the precomputations done by `Regex` construction can give\nsignificantly better performance than any of the `str`-based methods.\n\n### Example\n```rust\nRegex::new(\"^foobar\")\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "trivially_copy_pass_by_ref",
    "id_span": {
      "path": "src/pass_by_ref_or_value.rs",
      "line": 68
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for functions taking arguments by reference, where\nthe argument type is `Copy` and small enough to be more efficient to always\npass by value.\n\n### Why is this bad?\nIn many calling conventions instances of structs will\nbe passed through registers if they fit into two or less general purpose\nregisters.\n\n### Known problems\nThis lint is target register size dependent, it is\nlimited to 32-bit to try and reduce portability problems between 32 and\n64-bit, but if you are compiling for 8 or 16-bit targets then the limit\nwill be different.\n\nThe configuration option `trivial_copy_size_limit` can be set to override\nthis limit for a project.\n\nThis lint attempts to allow passing arguments by reference if a reference\nto that argument is returned. This is implemented by comparing the lifetime\nof the argument and return value for equality. However, this can cause\nfalse positives in cases involving multiple lifetimes that are bounded by\neach other.\n\nAlso, it does not take account of other similar cases where getting memory addresses\nmatters; namely, returning the pointer to the argument in question,\nand passing the argument, as both references and pointers,\nto a function that needs the memory address. For further details, refer to\n[this issue](https://github.com/rust-lang/rust-clippy/issues/5953)\nthat explains a real case in which this false positive\nled to an **undefined behaviour** introduced with unsafe code.\n\n### Example\n\n```rust\n// Bad\nfn foo(v: &u32) {}\n```\n\n```rust\n// Better\nfn foo(v: u32) {}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n* `trivial-copy-size-limit`: `Option<u64>`: The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference. (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "try_err",
    "id_span": {
      "path": "src/try_err.rs",
      "line": 44
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usages of `Err(x)?`.\n\n### Why is this bad?\nThe `?` operator is designed to allow calls that\ncan fail to be easily chained. For example, `foo()?.bar()` or\n`foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\nalways return), it is more clear to write `return Err(x)`.\n\n### Example\n```rust\nfn foo(fail: bool) -> Result<i32, String> {\n    if fail {\n      Err(\"failed\")?;\n    }\n    Ok(0)\n}\n```\nCould be written:\n\n```rust\nfn foo(fail: bool) -> Result<i32, String> {\n    if fail {\n      return Err(\"failed\".into());\n    }\n    Ok(0)\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "type_complexity",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 258
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for types used in structs, parameters and `let`\ndeclarations above a certain complexity threshold.\n\n### Why is this bad?\nToo complex types make the code less readable. Consider\nusing a `type` definition to simplify them.\n\n### Example\n```rust\nstruct Foo {\n    inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `type-complexity-threshold`: `u64`: The maximum complexity a type can have (defaults to `250`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "type_repetition_in_bounds",
    "id_span": {
      "path": "src/trait_bounds.rs",
      "line": 31
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nThis lint warns about unnecessary type repetitions in trait bounds\n\n### Why is this bad?\nRepeating the type for every bound makes the code\nless readable than combining the bounds\n\n### Example\n```rust\npub fn foo<T>(t: T) where T: Copy, T: Clone {}\n```\n\nCould be written as:\n\n```rust\npub fn foo<T>(t: T) where T: Copy + Clone {}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `max-trait-bounds`: `u64`: The maximum number of bounds a trait can have to be linted (defaults to `3`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "undocumented_unsafe_blocks",
    "id_span": {
      "path": "src/undocumented_unsafe_blocks.rs",
      "line": 42
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `unsafe` blocks without a `// Safety: ` comment\nexplaining why the unsafe operations performed inside\nthe block are safe.\n\n### Why is this bad?\nUndocumented unsafe blocks can make it difficult to\nread and maintain code, as well as uncover unsoundness\nand bugs.\n\n### Example\n```rust\nuse std::ptr::NonNull;\nlet a = &mut 42;\n\nlet ptr = unsafe { NonNull::new_unchecked(a) };\n```\nUse instead:\n```rust\nuse std::ptr::NonNull;\nlet a = &mut 42;\n\n// Safety: references are guaranteed to be non-null.\nlet ptr = unsafe { NonNull::new_unchecked(a) };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "undropped_manually_drops",
    "id_span": {
      "path": "src/undropped_manually_drops.rs",
      "line": 31
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nPrevents the safe `std::mem::drop` function from being called on `std::mem::ManuallyDrop`.\n\n### Why is this bad?\nThe safe `drop` function does not drop the inner value of a `ManuallyDrop`.\n\n### Known problems\nDoes not catch cases if the user binds `std::mem::drop`\nto a different name and calls it that way.\n\n### Example\n```rust\nstruct S;\ndrop(std::mem::ManuallyDrop::new(S));\n```\nUse instead:\n```rust\nstruct S;\nunsafe {\n    std::mem::ManuallyDrop::drop(&mut std::mem::ManuallyDrop::new(S));\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unicode_not_nfc",
    "id_span": {
      "path": "src/unicode.rs",
      "line": 65
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for string literals that contain Unicode in a form\nthat is not equal to its\n[NFC-recomposition](http://www.unicode.org/reports/tr15/#Norm_Forms).\n\n### Why is this bad?\nIf such a string is compared to another, the results\nmay be surprising.\n\n### Example\nYou may not see it, but \"à\"\" and \"à\"\" aren't the same string. The\nformer when escaped is actually `\"a\\u{300}\"` while the latter is `\"\\u{e0}\"`.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unimplemented",
    "id_span": {
      "path": "src/panic_unimplemented.rs",
      "line": 36
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `unimplemented!`.\n\n### Why is this bad?\nThis macro should not be present in production code\n\n### Example\n```rust\nunimplemented!();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "uninit_assumed_init",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1329
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `MaybeUninit::uninit().assume_init()`.\n\n### Why is this bad?\nFor most types, this is undefined behavior.\n\n### Known problems\nFor now, we accept empty tuples and tuples / arrays\nof `MaybeUninit`. There may be other types that allow uninitialized\ndata, but those are not yet rigorously defined.\n\n### Example\n```rust\n// Beware the UB\nuse std::mem::MaybeUninit;\n\nlet _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n```\n\nNote that the following is OK:\n\n```rust\nuse std::mem::MaybeUninit;\n\nlet _: [MaybeUninit<bool>; 5] = unsafe {\n    MaybeUninit::uninit().assume_init()\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "uninit_vec",
    "id_span": {
      "path": "src/uninit_vec.rs",
      "line": 55
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `set_len()` call that creates `Vec` with uninitialized elements.\nThis is commonly caused by calling `set_len()` right after allocating or\nreserving a buffer with `new()`, `default()`, `with_capacity()`, or `reserve()`.\n\n### Why is this bad?\nIt creates a `Vec` with uninitialized data, which leads to\nundefined behavior with most safe operations. Notably, uninitialized\n`Vec<u8>` must not be used with generic `Read`.\n\nMoreover, calling `set_len()` on a `Vec` created with `new()` or `default()`\ncreates out-of-bound values that lead to heap memory corruption when used.\n\n### Known Problems\nThis lint only checks directly adjacent statements.\n\n### Example\n```rust\nlet mut vec: Vec<u8> = Vec::with_capacity(1000);\nunsafe { vec.set_len(1000); }\nreader.read(&mut vec); // undefined behavior!\n```\n\n### How to fix?\n1. Use an initialized buffer:\n```rust\n   let mut vec: Vec<u8> = vec![0; 1000];\n   reader.read(&mut vec);\n   ```\n2. Wrap the content in `MaybeUninit`:\n```rust\n   let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n   vec.set_len(1000);  // `MaybeUninit` can be uninitialized\n   ```\n3. If you are on nightly, `Vec::spare_capacity_mut()` is available:\n```rust\n   let mut vec: Vec<u8> = Vec::with_capacity(1000);\n   let remaining = vec.spare_capacity_mut();  // `&mut [MaybeUninit<u8>]`\n   // perform initialization with `remaining`\n   vec.set_len(...);  // Safe to call `set_len()` on initialized part\n   ```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unit_arg",
    "id_span": {
      "path": "src/unit_types/mod.rs",
      "line": 91
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for passing a unit value as an argument to a function without using a\nunit literal (`()`).\n\n### Why is this bad?\nThis is likely the result of an accidental semicolon.\n\n### Example\n```rust\nfoo({\n    let a = bar();\n    baz(a);\n})\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unit_cmp",
    "id_span": {
      "path": "src/unit_types/mod.rs",
      "line": 71
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for comparisons to unit. This includes all binary\ncomparisons (like `==` and `<`) and asserts.\n\n### Why is this bad?\nUnit is always equal to itself, and thus is just a\nclumsily written constant. Mostly this happens when someone accidentally\nadds semicolons at the end of the operands.\n\n### Example\n```rust\nif {\n    foo();\n} == {\n    bar();\n} {\n    baz();\n}\n```\nis equal to\n```rust\n{\n    foo();\n    bar();\n    baz();\n}\n```\n\nFor asserts:\n```rust\nassert_eq!({ foo(); }, { bar(); });\n```\nwill always succeed",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unit_hash",
    "id_span": {
      "path": "src/unit_hash.rs",
      "line": 42
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nDetects `().hash(_)`.\n\n### Why is this bad?\nHashing a unit value doesn't do anything as the implementation of `Hash` for `()` is a no-op.\n\n### Example\n```rust\nmatch my_enum {\n\tEmpty => ().hash(&mut state),\n\tWithValue(x) => x.hash(&mut state),\n}\n```\nUse instead:\n```rust\nmatch my_enum {\n\tEmpty => 0_u8.hash(&mut state),\n\tWithValue(x) => x.hash(&mut state),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "unit_return_expecting_ord",
    "id_span": {
      "path": "src/unit_return_expecting_ord.rs",
      "line": 33
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for functions that expect closures of type\nFn(...) -> Ord where the implemented closure returns the unit type.\nThe lint also suggests to remove the semi-colon at the end of the statement if present.\n\n### Why is this bad?\nLikely, returning the unit type is unintentional, and\ncould simply be caused by an extra semi-colon. Since () implements Ord\nit doesn't cause a compilation error.\nThis is the same reasoning behind the unit_cmp lint.\n\n### Known problems\nIf returning unit is intentional, then there is no\nway of specifying this without triggering needless_return lint\n\n### Example\n```rust\nlet mut twins = vec!((1, 1), (2, 2));\ntwins.sort_by_key(|x| { x.1; });\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unnecessary_cast",
    "id_span": {
      "path": "src/casts/mod.rs",
      "line": 166
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for casts to the same type, casts of int literals to integer types\nand casts of float literals to float types.\n\n### Why is this bad?\nIt's just unnecessary.\n\n### Example\n```rust\nlet _ = 2i32 as i32;\nlet _ = 0.5 as f32;\n```\n\nBetter:\n\n```rust\nlet _ = 2_i32;\nlet _ = 0.5_f32;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unnecessary_filter_map",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1253
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for `filter_map` calls which could be replaced by `filter` or `map`.\nMore specifically it checks if the closure provided is only performing one of the\nfilter or map operations and suggests the appropriate option.\n\n### Why is this bad?\nComplexity. The intent is also clearer if only a single\noperation is being performed.\n\n### Example\n```rust\nlet _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n\n// As there is no transformation of the argument this could be written as:\nlet _ = (0..3).filter(|&x| x > 2);\n```\n\n```rust\nlet _ = (0..4).filter_map(|x| Some(x + 1));\n\n// As there is no conditional check on the argument this could be written as:\nlet _ = (0..4).map(|x| x + 1);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unnecessary_fold",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1224
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for using `fold` when a more succinct alternative exists.\nSpecifically, this checks for `fold`s which could be replaced by `any`, `all`,\n`sum` or `product`.\n\n### Why is this bad?\nReadability.\n\n### Example\n```rust\nlet _ = (0..3).fold(false, |acc, x| acc || x > 2);\n```\nThis could be written as:\n```rust\nlet _ = (0..3).any(|x| x > 2);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unnecessary_lazy_evaluations",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1529
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nAs the counterpart to `or_fun_call`, this lint looks for unnecessary\nlazily evaluated closures on `Option` and `Result`.\n\nThis lint suggests changing the following functions, when eager evaluation results in\nsimpler code:\n - `unwrap_or_else` to `unwrap_or`\n - `and_then` to `and`\n - `or_else` to `or`\n - `get_or_insert_with` to `get_or_insert`\n - `ok_or_else` to `ok_or`\n\n### Why is this bad?\nUsing eager evaluation is shorter and simpler in some cases.\n\n### Known problems\nIt is possible, but not recommended for `Deref` and `Index` to have\nside effects. Eagerly evaluating them can change the semantics of the program.\n\n### Example\n```rust\n// example code where clippy issues a warning\nlet opt: Option<u32> = None;\n\nopt.unwrap_or_else(|| 42);\n```\nUse instead:\n```rust\nlet opt: Option<u32> = None;\n\nopt.unwrap_or(42);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unnecessary_mut_passed",
    "id_span": {
      "path": "src/mut_reference.rs",
      "line": 26
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nDetects passing a mutable reference to a function that only\nrequires an immutable reference.\n\n### Why is this bad?\nThe mutable reference rules out all other references to\nthe value. Also the code misleads about the intent of the call site.\n\n### Example\n```rust\n// Bad\nmy_vec.push(&mut value)\n\n// Good\nmy_vec.push(&value)\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unnecessary_operation",
    "id_span": {
      "path": "src/no_effect.rs",
      "line": 65
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for expression statements that can be reduced to a\nsub-expression.\n\n### Why is this bad?\nExpressions by themselves often have no side-effects.\nHaving such expressions reduces readability.\n\n### Example\n```rust\ncompute_array()[0];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unnecessary_self_imports",
    "id_span": {
      "path": "src/unnecessary_self_imports.rs",
      "line": 29
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for imports ending in `::{self}`.\n\n### Why is this bad?\nIn most cases, this can be written much more cleanly by omitting `::{self}`.\n\n### Known problems\nRemoving `::{self}` will cause any non-module items at the same path to also be imported.\nThis might cause a naming conflict (https://github.com/rust-lang/rustfmt/issues/3568). This lint makes no attempt\nto detect this scenario and that is why it is a restriction lint.\n\n### Example\n```rust\nuse std::io::{self};\n```\nUse instead:\n```rust\nuse std::io;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "unnecessary_sort_by",
    "id_span": {
      "path": "src/unnecessary_sort_by.rs",
      "line": 42
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nDetects uses of `Vec::sort_by` passing in a closure\nwhich compares the two arguments, either directly or indirectly.\n\n### Why is this bad?\nIt is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\npossible) than to use `Vec::sort_by` and a more complicated\nclosure.\n\n### Known problems\nIf the suggested `Vec::sort_by_key` uses Reverse and it isn't already\nimported by a use statement, then it will need to be added manually.\n\n### Example\n```rust\nvec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n```\nUse instead:\n```rust\nvec.sort_by_key(|a| a.foo());\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unnecessary_unwrap",
    "id_span": {
      "path": "src/unwrap.rs",
      "line": 42
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for calls of `unwrap[_err]()` that cannot fail.\n\n### Why is this bad?\nUsing `if let` or `match` is more idiomatic.\n\n### Example\n```rust\nif option.is_some() {\n    do_something_with(option.unwrap())\n}\n```\n\nCould be written:\n\n```rust\nif let Some(value) = option {\n    do_something_with(value)\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "unnecessary_wraps",
    "id_span": {
      "path": "src/unnecessary_wraps.rs",
      "line": 52
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for private functions that only return `Ok` or `Some`.\n\n### Why is this bad?\nIt is not meaningful to wrap values when no `None` or `Err` is returned.\n\n### Known problems\nThere can be false positives if the function signature is designed to\nfit some external requirement.\n\n### Example\n```rust\nfn get_cool_number(a: bool, b: bool) -> Option<i32> {\n    if a && b {\n        return Some(50);\n    }\n    if a {\n        Some(0)\n    } else {\n        Some(10)\n    }\n}\n```\nUse instead:\n```rust\nfn get_cool_number(a: bool, b: bool) -> i32 {\n    if a && b {\n        return 50;\n    }\n    if a {\n        0\n    } else {\n        10\n    }\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "unneeded_field_pattern",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 49
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for structure field patterns bound to wildcards.\n\n### Why is this bad?\nUsing `..` instead is shorter and leaves the focus on\nthe fields that are actually bound.\n\n### Example\n```rust\nlet f = Foo { a: 0, b: 0, c: 0 };\n\n// Bad\nmatch f {\n    Foo { a: _, b: 0, .. } => {},\n    Foo { a: _, b: _, c: _ } => {},\n}\n\n// Good\nmatch f {\n    Foo { b: 0, .. } => {},\n    Foo { .. } => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unneeded_wildcard_pattern",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 276
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for tuple patterns with a wildcard\npattern (`_`) is next to a rest pattern (`..`).\n\n_NOTE_: While `_, ..` means there is at least one element left, `..`\nmeans there are 0 or more elements left. This can make a difference\nwhen refactoring, but shouldn't result in errors in the refactored code,\nsince the wildcard pattern isn't used anyway.\n### Why is this bad?\nThe wildcard pattern is unneeded as the rest pattern\ncan match that element as well.\n\n### Example\n```rust\n// Bad\nmatch t {\n    TupleStruct(0, .., _) => (),\n    _ => (),\n}\n\n// Good\nmatch t {\n    TupleStruct(0, ..) => (),\n    _ => (),\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unnested_or_patterns",
    "id_span": {
      "path": "src/unnested_or_patterns.rs",
      "line": 42
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for unnested or-patterns, e.g., `Some(0) | Some(2)` and\nsuggests replacing the pattern with a nested one, `Some(0 | 2)`.\n\nAnother way to think of this is that it rewrites patterns in\n*disjunctive normal form (DNF)* into *conjunctive normal form (CNF)*.\n\n### Why is this bad?\nIn the example above, `Some` is repeated, which unncessarily complicates the pattern.\n\n### Example\n```rust\nfn main() {\n    if let Some(0) | Some(2) = Some(0) {}\n}\n```\nUse instead:\n```rust\nfn main() {\n    if let Some(0 | 2) = Some(0) {}\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unreachable",
    "id_span": {
      "path": "src/panic_unimplemented.rs",
      "line": 68
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for usage of `unreachable!`.\n\n### Why is this bad?\nThis macro can cause code to panic\n\n### Example\n```rust\nunreachable!();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unreadable_literal",
    "id_span": {
      "path": "src/literal_representation.rs",
      "line": 34
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nWarns if a long integral or floating-point constant does\nnot contain underscores.\n\n### Why is this bad?\nReading long numbers is difficult without separators.\n\n### Example\n```rust\n// Bad\nlet x: u64 = 61864918973511;\n\n// Good\nlet x: u64 = 61_864_918_973_511;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `unreadable-literal-lint-fractions`: `bool`: Should the fraction of a decimal be linted to include separators. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unsafe_derive_deserialize",
    "id_span": {
      "path": "src/derive.rs",
      "line": 150
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for deriving `serde::Deserialize` on a type that\nhas methods using `unsafe`.\n\n### Why is this bad?\nDeriving `serde::Deserialize` will create a constructor\nthat may violate invariants hold by another constructor.\n\n### Example\n```rust\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\npub struct Foo {\n    // ..\n}\n\nimpl Foo {\n    pub fn new() -> Self {\n        // setup here ..\n    }\n\n    pub unsafe fn parts() -> (&str, &str) {\n        // assumes invariants hold\n    }\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unsafe_removed_from_name",
    "id_span": {
      "path": "src/unsafe_removed_from_name.rs",
      "line": 24
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for imports that remove \"unsafe\" from an item's\nname.\n\n### Why is this bad?\nRenaming makes it less clear which traits and\nstructures are unsafe.\n\n### Example\n```rust\nuse std::cell::{UnsafeCell as TotallySafeCell};\n\nextern crate crossbeam;\nuse crossbeam::{spawn_unsafe as spawn};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unsafe_vector_initialization",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 120
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis lint used to suggest replacing `let mut vec =\nVec::with_capacity(n); vec.set_len(n);` with `let vec = vec![0; n];`. The\nreplacement has very different performance characteristics so the lint is\ndeprecated.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unseparated_literal_suffix",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 132
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nWarns if literal suffixes are not separated by an\nunderscore.\nTo enforce unseparated literal suffix style,\nsee the `separated_literal_suffix` lint.\n\n### Why is this bad?\nSuffix style should be consistent.\n\n### Example\n```rust\n// Bad\nlet y = 123832i32;\n\n// Good\nlet y = 123832_i32;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unsound_collection_transmute",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 340
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for transmutes between collections whose\ntypes have different ABI, size or alignment.\n\n### Why is this bad?\nThis is undefined behavior.\n\n### Known problems\nCurrently, we cannot know whether a type is a\ncollection, so we just lint the ones that come with `std`.\n\n### Example\n```rust\n// different size, therefore likely out-of-bounds memory access\n// You absolutely do not want this in your code!\nunsafe {\n    std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n};\n```\n\nYou must always iterate, map and collect the values:\n\n```rust\nvec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unstable_as_mut_slice",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 70
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis used to check for `Vec::as_mut_slice`, which was unstable with good\nstable alternatives. `Vec::as_mut_slice` has now been stabilized.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unstable_as_slice",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 59
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis used to check for `Vec::as_slice`, which was unstable with good\nstable alternatives. `Vec::as_slice` has now been stabilized.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unused_async",
    "id_span": {
      "path": "src/unused_async.rs",
      "line": 32
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for functions that are declared `async` but have no `.await`s inside of them.\n\n### Why is this bad?\nAsync functions with no async code create overhead, both mentally and computationally.\nCallers of async methods either need to be calling from an async function themselves or run it on an executor, both of which\ncauses runtime overhead and hassle for the caller.\n\n### Example\n```rust\n// Bad\nasync fn get_random_number() -> i64 {\n    4 // Chosen by fair dice roll. Guaranteed to be random.\n}\nlet number_future = get_random_number();\n\n// Good\nfn get_random_number_improved() -> i64 {\n    4 // Chosen by fair dice roll. Guaranteed to be random.\n}\nlet number_future = async { get_random_number_improved() };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unused_collect",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 130
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThis lint has been superseded by #[must_use] in rustc.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unused_io_amount",
    "id_span": {
      "path": "src/unused_io_amount.rs",
      "line": 32
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for unused written/read amount.\n\n### Why is this bad?\n`io::Write::write(_vectored)` and\n`io::Read::read(_vectored)` are not guaranteed to\nprocess the entire buffer. They return how many bytes were processed, which\nmight be smaller\nthan a given buffer's length. If you don't need to deal with\npartial-write/read, use\n`write_all`/`read_exact` instead.\n\n### Known problems\nDetects only common patterns.\n\n### Example\n```rust\nuse std::io;\nfn foo<W: io::Write>(w: &mut W) -> io::Result<()> {\n    // must be `w.write_all(b\"foo\")?;`\n    w.write(b\"foo\")?;\n    Ok(())\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unused_self",
    "id_span": {
      "path": "src/unused_self.rs",
      "line": 32
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks methods that contain a `self` argument but don't use it\n\n### Why is this bad?\nIt may be clearer to define the method as an associated function instead\nof an instance method if it doesn't require `self`.\n\n### Example\n```rust\nstruct A;\nimpl A {\n    fn method(&self) {}\n}\n```\n\nCould be written:\n\n```rust\nstruct A;\nimpl A {\n    fn method() {}\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unused_unit",
    "id_span": {
      "path": "src/unused_unit.rs",
      "line": 31
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for unit (`()`) expressions that can be removed.\n\n### Why is this bad?\nSuch expressions add no value, but can make the code\nless readable. Depending on formatting they can make a `break` or `return`\nstatement look like a function call.\n\n### Example\n```rust\nfn return_unit() -> () {\n    ()\n}\n```\nis equivalent to\n```rust\nfn return_unit() {}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unusual_byte_groupings",
    "id_span": {
      "path": "src/literal_representation.rs",
      "line": 99
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nWarns if hexadecimal or binary literals are not grouped\nby nibble or byte.\n\n### Why is this bad?\nNegatively impacts readability.\n\n### Example\n```rust\nlet x: u32 = 0xFFF_FFF;\nlet y: u8 = 0b01_011_101;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unwrap_in_result",
    "id_span": {
      "path": "src/unwrap_in_result.rs",
      "line": 54
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for functions of type `Result` that contain `expect()` or `unwrap()`\n\n### Why is this bad?\nThese functions promote recoverable errors to non-recoverable errors which may be undesirable in code bases which wish to avoid panics.\n\n### Known problems\nThis can cause false positives in functions that handle both recoverable and non recoverable errors.\n\n### Example\nBefore:\n```rust\nfn divisible_by_3(i_str: String) -> Result<(), String> {\n    let i = i_str\n        .parse::<i32>()\n        .expect(\"cannot divide the input by three\");\n\n    if i % 3 != 0 {\n        Err(\"Number is not divisible by 3\")?\n    }\n\n    Ok(())\n}\n```\n\nAfter:\n```rust\nfn divisible_by_3(i_str: String) -> Result<(), String> {\n    let i = i_str\n        .parse::<i32>()\n        .map_err(|e| format!(\"cannot divide the input by three: {}\", e))?;\n\n    if i % 3 != 0 {\n        Err(\"Number is not divisible by 3\")?\n    }\n\n    Ok(())\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "unwrap_or_else_default",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 338
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for usages of `_.unwrap_or_else(Default::default)` on `Option` and\n`Result` values.\n\n### Why is this bad?\nReadability, these can be written as `_.unwrap_or_default`, which is\nsimpler and more concise.\n\n### Examples\n```rust\n\n// Bad\nx.unwrap_or_else(Default::default);\nx.unwrap_or_else(u32::default);\n\n// Good\nx.unwrap_or_default();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "unwrap_used",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 169
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for `.unwrap()` calls on `Option`s and on `Result`s.\n\n### Why is this bad?\nIt is better to handle the `None` or `Err` case,\nor at least call `.expect(_)` with a more helpful message. Still, for a lot of\nquick-and-dirty code, `unwrap` is a good choice, which is why this lint is\n`Allow` by default.\n\n`result.unwrap()` will let the thread panic on `Err` values.\nNormally, you want to implement more sophisticated error handling,\nand propagate errors upwards with `?` operator.\n\nEven if you want to panic on errors, not all `Error`s implement good\nmessages on display. Therefore, it may be beneficial to look at the places\nwhere they may get displayed. Activate this lint to do just that.\n\n### Examples\n```rust\n\n// Bad\nopt.unwrap();\n\n// Good\nopt.expect(\"more helpful message\");\n```\n\n// or\n\n```rust\n\n// Bad\nres.unwrap();\n\n// Good\nres.expect(\"more helpful message\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "upper_case_acronyms",
    "id_span": {
      "path": "src/upper_case_acronyms.rs",
      "line": 36
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for fully capitalized names and optionally names containing a capitalized acronym.\n\n### Why is this bad?\nIn CamelCase, acronyms count as one word.\nSee [naming conventions](https://rust-lang.github.io/api-guidelines/naming.html#casing-conforms-to-rfc-430-c-case)\nfor more.\n\nBy default, the lint only triggers on fully-capitalized names.\nYou can use the `upper-case-acronyms-aggressive: true` config option to enable linting\non all camel case names\n\n### Known problems\nWhen two acronyms are contiguous, the lint can't tell where\nthe first acronym ends and the second starts, so it suggests to lowercase all of\nthe letters in the second acronym.\n\n### Example\n```rust\nstruct HTTPResponse;\n```\nUse instead:\n```rust\nstruct HttpResponse;\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n* `upper-case-acronyms-aggressive`: `bool`: Enables verbose mode. Triggers if there is more than one uppercase char next to each other (defaults to `false`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "use_debug",
    "id_span": {
      "path": "src/write.rs",
      "line": 119
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for use of `Debug` formatting. The purpose of this\nlint is to catch debugging remnants.\n\n### Why is this bad?\nThe purpose of the `Debug` trait is to facilitate\ndebugging Rust code. It should not be used in user-facing output.\n\n### Example\n```rust\nprintln!(\"{:?}\", foo);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "use_self",
    "id_span": {
      "path": "src/use_self.rs",
      "line": 54
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for unnecessary repetition of structure name when a\nreplacement with `Self` is applicable.\n\n### Why is this bad?\nUnnecessary repetition. Mixed use of `Self` and struct\nname\nfeels inconsistent.\n\n### Known problems\n- Unaddressed false negative in fn bodies of trait implementations\n- False positive with assotiated types in traits (#4140)\n\n### Example\n```rust\nstruct Foo {}\nimpl Foo {\n    fn new() -> Foo {\n        Foo {}\n    }\n}\n```\ncould be\n```rust\nstruct Foo {}\nimpl Foo {\n    fn new() -> Self {\n        Self {}\n    }\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `msrv`: `Option<String>`: The minimum rust version that the project supports (defaults to `None`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "used_underscore_binding",
    "id_span": {
      "path": "src/misc.rs",
      "line": 190
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for the use of bindings with a single leading\nunderscore.\n\n### Why is this bad?\nA single leading underscore is usually used to indicate\nthat a binding will not be used. Using such a binding breaks this\nexpectation.\n\n### Known problems\nThe lint does not work properly with desugaring and\nmacro, it has been allowed in the mean time.\n\n### Example\n```rust\nlet _x = 0;\nlet y = _x + 1; // Here we are using `_x`, even though it has a leading\n                // underscore. We should rename `_x` to `x`\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "useless_asref",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1202
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `.as_ref()` or `.as_mut()` where the\ntypes before and after the call are the same.\n\n### Why is this bad?\nThe call is unnecessary.\n\n### Example\n```rust\nlet x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x.as_ref());\n```\nThe correct use would be:\n```rust\nlet x: &[i32] = &[1, 2, 3, 4, 5];\ndo_stuff(x);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "useless_attribute",
    "id_span": {
      "path": "src/attrs.rs",
      "line": 101
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `extern crate` and `use` items annotated with\nlint attributes.\n\nThis lint permits `#[allow(unused_imports)]`, `#[allow(deprecated)]`,\n`#[allow(unreachable_pub)]`, `#[allow(clippy::wildcard_imports)]` and\n`#[allow(clippy::enum_glob_use)]` on `use` items and `#[allow(unused_imports)]` on\n`extern crate` items with a `#[macro_use]` attribute.\n\n### Why is this bad?\nLint attributes have no effect on crate imports. Most\nlikely a `!` was forgotten.\n\n### Example\n```rust\n// Bad\n#[deny(dead_code)]\nextern crate foo;\n#[forbid(dead_code)]\nuse foo::bar;\n\n// Ok\n#[allow(unused_imports)]\nuse foo::baz;\n#[allow(unused_imports)]\n#[macro_use]\nextern crate baz;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "useless_conversion",
    "id_span": {
      "path": "src/useless_conversion.rs",
      "line": 31
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for `Into`, `TryInto`, `From`, `TryFrom`, or `IntoIter` calls\nwhich uselessly convert to the same type.\n\n### Why is this bad?\nRedundant code.\n\n### Example\n```rust\n// Bad\n// format!() returns a `String`\nlet s: String = format!(\"hello\").into();\n\n// Good\nlet s: String = format!(\"hello\");\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "useless_format",
    "id_span": {
      "path": "src/format.rs",
      "line": 36
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for the use of `format!(\"string literal with no\nargument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n\n### Why is this bad?\nThere is no point of doing that. `format!(\"foo\")` can\nbe replaced by `\"foo\".to_owned()` if you really need a `String`. The even\nworse `&format!(\"foo\")` is often encountered in the wild. `format!(\"{}\",\nfoo)` can be replaced by `foo.clone()` if `foo: String` or `foo.to_owned()`\nif `foo: &str`.\n\n### Examples\n```rust\n\n// Bad\nlet foo = \"foo\";\nformat!(\"{}\", foo);\n\n// Good\nfoo.to_owned();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "useless_let_if_seq",
    "id_span": {
      "path": "src/let_if_seq.rs",
      "line": 51
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for variable declarations immediately followed by a\nconditional affectation.\n\n### Why is this bad?\nThis is not idiomatic Rust.\n\n### Example\n```rust\nlet foo;\n\nif bar() {\n    foo = 42;\n} else {\n    foo = 0;\n}\n\nlet mut baz = None;\n\nif bar() {\n    baz = Some(42);\n}\n```\n\nshould be written\n\n```rust\nlet foo = if bar() {\n    42\n} else {\n    0\n};\n\nlet baz = if bar() {\n    Some(42)\n} else {\n    None\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "useless_transmute",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 58
    },
    "group": "nursery",
    "level": "allow",
    "docs": " ### What it does\nChecks for transmutes to the original type of the object\nand transmutes that could be a cast.\n\n### Why is this bad?\nReadability. The code tricks people into thinking that\nsomething complex is going on.\n\n### Example\n```rust\ncore::intrinsics::transmute(t); // where the result type is the same as `t`'s\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unspecified"
    }
  },
  {
    "id": "useless_vec",
    "id_span": {
      "path": "src/vec.rs",
      "line": 39
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for usage of `&vec![..]` when using `&[..]` would\nbe possible.\n\n### Why is this bad?\nThis is less efficient.\n\n### Example\n```rust\n\n// Bad\nfoo(&vec![1, 2]);\n\n// Good\nfoo(&[1, 2]);\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `too-large-for-stack`: `u64`: The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap (defaults to `200`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "vec_box",
    "id_span": {
      "path": "src/types/mod.rs",
      "line": 78
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for use of `Vec<Box<T>>` where T: Sized anywhere in the code.\nCheck the [Box documentation](https://doc.rust-lang.org/std/boxed/index.html) for more information.\n\n### Why is this bad?\n`Vec` already keeps its contents in a separate area on\nthe heap. So if you `Box` its contents, you just add another level of indirection.\n\n### Known problems\nVec<Box<T: Sized>> makes sense if T is a large type (see [#3530](https://github.com/rust-lang/rust-clippy/issues/3530),\n1st comment).\n\n### Example\n```rust\nstruct X {\n    values: Vec<Box<i32>>,\n}\n```\n\nBetter:\n\n```rust\nstruct X {\n    values: Vec<i32>,\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n* `vec-box-size-threshold`: `u64`: The size of the boxed type in bytes, where boxing in a `Vec` is allowed (defaults to `4096`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "vec_init_then_push",
    "id_span": {
      "path": "src/vec_init_then_push.rs",
      "line": 30
    },
    "group": "perf",
    "level": "warn",
    "docs": " ### What it does\nChecks for calls to `push` immediately after creating a new `Vec`.\n\n### Why is this bad?\nThe `vec![]` macro is both more performant and easier to read than\nmultiple `push` calls.\n\n### Example\n```rust\nlet mut v = Vec::new();\nv.push(0);\n```\nUse instead:\n```rust\nlet v = vec![0];\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "vec_resize_to_zero",
    "id_span": {
      "path": "src/vec_resize_to_zero.rs",
      "line": 23
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nFinds occurrences of `Vec::resize(0, an_int)`\n\n### Why is this bad?\nThis is probably an argument inversion mistake.\n\n### Example\n```rust\nvec!(1, 2, 3, 4, 5).resize(0, 5)\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "verbose_bit_mask",
    "id_span": {
      "path": "src/bit_mask.rs",
      "line": 98
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for bit masks that can be replaced by a call\nto `trailing_zeros`\n\n### Why is this bad?\n`x.trailing_zeros() > 4` is much clearer than `x & 15\n== 0`\n\n### Known problems\nllvm generates better code for `x & 15 == 0` on x86\n\n### Example\n```rust\nif x & 0b1111 == 0 { }\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `verbose-bit-mask-threshold`: `u64`: The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros' (defaults to `1`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "verbose_file_reads",
    "id_span": {
      "path": "src/verbose_file_reads.rs",
      "line": 30
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for use of File::read_to_end and File::read_to_string.\n\n### Why is this bad?\n`fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\nSee also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)\n\n### Example\n```rust\nlet mut f = File::open(\"foo.txt\").unwrap();\nlet mut bytes = Vec::new();\nf.read_to_end(&mut bytes).unwrap();\n```\nCan be written more concisely as\n```rust\nlet mut bytes = fs::read(\"foo.txt\").unwrap();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "vtable_address_comparisons",
    "id_span": {
      "path": "src/unnamed_address.rs",
      "line": 50
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for comparisons with an address of a trait vtable.\n\n### Why is this bad?\nComparing trait objects pointers compares an vtable addresses which\nare not guaranteed to be unique and could vary between different code generation units.\nFurthermore vtables for different types could have the same address after being merged\ntogether.\n\n### Example\n```rust\nlet a: Rc<dyn Trait> = ...\nlet b: Rc<dyn Trait> = ...\nif Rc::ptr_eq(&a, &b) {\n    ...\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "while_immutable_condition",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 449
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks whether variables used within while loop condition\ncan be (and are) mutated in the body.\n\n### Why is this bad?\nIf the condition is unchanged, entering the body of the loop\nwill lead to an infinite loop.\n\n### Known problems\nIf the `while`-loop is in a closure, the check for mutation of the\ncondition variables in the body can cause false negatives. For example when only `Upvar` `a` is\nin the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n\n### Example\n```rust\nlet i = 0;\nwhile i > 10 {\n    println!(\"let me loop forever!\");\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "while_let_loop",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 236
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nDetects `loop + match` combinations that are easier\nwritten as a `while let` loop.\n\n### Why is this bad?\nThe `while let` loop is usually shorter and more\nreadable.\n\n### Known problems\nSometimes the wrong binding is displayed ([#383](https://github.com/rust-lang/rust-clippy/issues/383)).\n\n### Example\n```rust\nloop {\n    let x = match y {\n        Some(x) => x,\n        None => break,\n    };\n    // .. do something with x\n}\n// is easier written as\nwhile let Some(x) = y {\n    // .. do something with x\n};\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "HasPlaceholders"
    }
  },
  {
    "id": "while_let_on_iterator",
    "id_span": {
      "path": "src/loops/mod.rs",
      "line": 339
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for `while let` expressions on iterators.\n\n### Why is this bad?\nReadability. A simple `for` loop is shorter and conveys\nthe intent better.\n\n### Example\n```rust\nwhile let Some(val) = iter() {\n    ..\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "wildcard_dependencies",
    "id_span": {
      "path": "src/wildcard_dependencies.rs",
      "line": 23
    },
    "group": "cargo",
    "level": "allow",
    "docs": " ### What it does\nChecks for wildcard dependencies in the `Cargo.toml`.\n\n### Why is this bad?\n[As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),\nit is highly unlikely that you work with any possible version of your dependency,\nand wildcard dependencies would cause unnecessary breakage in the ecosystem.\n\n### Example\n```toml\n[dependencies]\nregex = \"*\"\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "wildcard_enum_match_arm",
    "id_span": {
      "path": "src/matches.rs",
      "line": 271
    },
    "group": "restriction",
    "level": "allow",
    "docs": " ### What it does\nChecks for wildcard enum matches using `_`.\n\n### Why is this bad?\nNew enum variants added by library updates can be missed.\n\n### Known problems\nSuggested replacements may be incorrect if guards exhaustively cover some\nvariants, and also may not use correct path to enum if it's not present in the current scope.\n\n### Example\n```rust\n// Bad\nmatch x {\n    Foo::A(_) => {},\n    _ => {},\n}\n\n// Good\nmatch x {\n    Foo::A(_) => {},\n    Foo::B(_) => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "wildcard_imports",
    "id_span": {
      "path": "src/wildcard_imports.rs",
      "line": 89
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for wildcard imports `use _::*`.\n\n### Why is this bad?\nwildcard imports can pollute the namespace. This is especially bad if\nyou try to import something through a wildcard, that already has been imported by name from\na different source:\n\n```rust\nuse crate1::foo; // Imports a function named foo\nuse crate2::*; // Has a function named foo\n\nfoo(); // Calls crate1::foo\n```\n\nThis can lead to confusing error messages at best and to unexpected behavior at worst.\n\n### Exceptions\nWildcard imports are allowed from modules named `prelude`. Many crates (including the standard library)\nprovide modules named \"prelude\" specifically designed for wildcard import.\n\n`use super::*` is allowed in test modules. This is defined as any module with \"test\" in the name.\n\nThese exceptions can be disabled using the `warn-on-all-wildcard-imports` configuration flag.\n\n### Known problems\nIf macros are imported through the wildcard, this macro is not included\nby the suggestion and has to be added by hand.\n\nApplying the suggestion when explicit imports of the things imported with a glob import\nexist, may result in `unused_imports` warnings.\n\n### Example\n```rust\n// Bad\nuse crate1::*;\n\nfoo();\n```\n\n```rust\n// Good\nuse crate1::foo;\n\nfoo();\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `warn-on-all-wildcard-imports`: `bool`: Whether to allow certain wildcard imports (prelude, super in tests). (defaults to `false`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "wildcard_in_or_patterns",
    "id_span": {
      "path": "src/matches.rs",
      "line": 332
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for wildcard pattern used with others patterns in same match arm.\n\n### Why is this bad?\nWildcard pattern already covers any other pattern as it will match anyway.\nIt makes the code less readable, especially to spot wildcard pattern use in match arm.\n\n### Example\n```rust\n// Bad\nmatch \"foo\" {\n    \"a\" => {},\n    \"bar\" | _ => {},\n}\n\n// Good\nmatch \"foo\" {\n    \"a\" => {},\n    _ => {},\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "write_literal",
    "id_span": {
      "path": "src/write.rs",
      "line": 222
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns about the use of literals as `write!`/`writeln!` args.\n\n### Why is this bad?\nUsing literals as `writeln!` args is inefficient\n(c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n(i.e., just put the literal in the format string)\n\n### Known problems\nWill also warn with macro calls as arguments that expand to literals\n-- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n\n### Example\n```rust\n// Bad\nwriteln!(buf, \"{}\", \"foo\");\n\n// Good\nwriteln!(buf, \"foo\");\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "write_with_newline",
    "id_span": {
      "path": "src/write.rs",
      "line": 194
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns when you use `write!()` with a format\nstring that\nends in a newline.\n\n### Why is this bad?\nYou should use `writeln!()` instead, which appends the\nnewline.\n\n### Example\n```rust\n// Bad\nwrite!(buf, \"Hello {}!\\n\", name);\n\n// Good\nwriteln!(buf, \"Hello {}!\", name);\n```",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "writeln_empty_string",
    "id_span": {
      "path": "src/write.rs",
      "line": 168
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nThis lint warns when you use `writeln!(buf, \"\")` to\nprint a newline.\n\n### Why is this bad?\nYou should use `writeln!(buf)`, which is simpler.\n\n### Example\n```rust\n// Bad\nwriteln!(buf, \"\");\n\n// Good\nwriteln!(buf);\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "wrong_pub_self_convention",
    "id_span": {
      "path": "src/deprecated_lints.rs",
      "line": 195
    },
    "group": "deprecated",
    "level": "none",
    "docs": " ### What it does\nNothing. This lint has been deprecated.\n\n### Deprecation reason\nThe `avoid_breaking_exported_api` config option was added, which\nenables the `wrong_self_conversion` lint for public items.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "wrong_self_convention",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 287
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nChecks for methods with certain name prefixes and which\ndoesn't match how self is taken. The actual rules are:\n\n|Prefix |Postfix     |`self` taken           | `self` type  |\n|-------|------------|-----------------------|--------------|\n|`as_`  | none       |`&self` or `&mut self` | any          |\n|`from_`| none       | none                  | any          |\n|`into_`| none       |`self`                 | any          |\n|`is_`  | none       |`&self` or none        | any          |\n|`to_`  | `_mut`     |`&mut self`            | any          |\n|`to_`  | not `_mut` |`self`                 | `Copy`       |\n|`to_`  | not `_mut` |`&self`                | not `Copy`   |\n\nNote: Clippy doesn't trigger methods with `to_` prefix in:\n- Traits definition.\nClippy can not tell if a type that implements a trait is `Copy` or not.\n- Traits implementation, when `&self` is taken.\nThe method signature is controlled by the trait and often `&self` is required for all types that implement the trait\n(see e.g. the `std::string::ToString` trait).\n\nClippy allows `Pin<&Self>` and `Pin<&mut Self>` if `&self` and `&mut self` is required.\n\nPlease find more info here:\nhttps://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n\n### Why is this bad?\nConsistency breeds readability. If you follow the\nconventions, your users won't be surprised that they, e.g., need to supply a\nmutable reference to a `as_..` function.\n\n### Example\n```rust\nimpl X {\n    fn as_str(self) -> &'static str {\n        // ..\n    }\n}\n```\n### Configuration\nThis lint has the following configuration variables:\n\n* `avoid-breaking-exported-api`: `bool`: Suppress lints whenever the suggested change would cause breakage for other crates. (defaults to `true`)\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "wrong_transmute",
    "id_span": {
      "path": "src/transmute/mod.rs",
      "line": 39
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for transmutes that can't ever be correct on any\narchitecture.\n\n### Why is this bad?\nIt's basically guaranteed to be undefined behaviour.\n\n### Known problems\nWhen accessing C, users might want to store pointer\nsized objects in `extradata` arguments to save an allocation.\n\n### Example\n```rust\nlet ptr: *const T = core::intrinsics::transmute('x')\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "zero_divided_by_zero",
    "id_span": {
      "path": "src/zero_div_zero.rs",
      "line": 23
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nChecks for `0.0 / 0.0`.\n\n### Why is this bad?\nIt's less readable than `f32::NAN` or `f64::NAN`.\n\n### Example\n```rust\n// Bad\nlet nan = 0.0f32 / 0.0;\n\n// Good\nlet nan = f32::NAN;\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "zero_prefixed_literal",
    "id_span": {
      "path": "src/misc_early/mod.rs",
      "line": 192
    },
    "group": "complexity",
    "level": "warn",
    "docs": " ### What it does\nWarns if an integral constant literal starts with `0`.\n\n### Why is this bad?\nIn some languages (including the infamous C language\nand most of its\nfamily), this marks an octal constant. In Rust however, this is a decimal\nconstant. This could\nbe confusing for both the writer and a reader of the constant.\n\n### Example\n\nIn Rust:\n```rust\nfn main() {\n    let a = 0123;\n    println!(\"{}\", a);\n}\n```\n\nprints `123`, while in C:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int a = 0123;\n    printf(\"%d\\n\", a);\n}\n```\n\nprints `83` (as `83 == 0o123` while `123 == 0o173`).",
    "applicability": {
      "is_multi_part_suggestion": true,
      "applicability": "MaybeIncorrect"
    }
  },
  {
    "id": "zero_ptr",
    "id_span": {
      "path": "src/misc.rs",
      "line": 231
    },
    "group": "style",
    "level": "warn",
    "docs": " ### What it does\nCatch casts from `0` to some pointer type\n\n### Why is this bad?\nThis generally means `null` and is better expressed as\n{`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n\n### Example\n```rust\n// Bad\nlet a = 0 as *const u32;\n\n// Good\nlet a = std::ptr::null::<u32>();\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "MachineApplicable"
    }
  },
  {
    "id": "zero_sized_map_values",
    "id_span": {
      "path": "src/zero_sized_map_values.rs",
      "line": 39
    },
    "group": "pedantic",
    "level": "allow",
    "docs": " ### What it does\nChecks for maps with zero-sized value types anywhere in the code.\n\n### Why is this bad?\nSince there is only a single value for a zero-sized type, a map\ncontaining zero sized values is effectively a set. Using a set in that case improves\nreadability and communicates intent more clearly.\n\n### Known problems\n* A zero-sized type cannot be recovered later if it contains private fields.\n* This lints the signature of public items\n\n### Example\n```rust\nfn unique_words(text: &str) -> HashMap<&str, ()> {\n    todo!();\n}\n```\nUse instead:\n```rust\nfn unique_words(text: &str) -> HashSet<&str> {\n    todo!();\n}\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "zst_offset",
    "id_span": {
      "path": "src/methods/mod.rs",
      "line": 1374
    },
    "group": "correctness",
    "level": "deny",
    "docs": " ### What it does\nChecks for `offset(_)`, `wrapping_`{`add`, `sub`}, etc. on raw pointers to\nzero-sized types\n\n### Why is this bad?\nThis is a no-op, and likely unintended\n\n### Example\n```rust\nunsafe { (&() as *const ()).offset(1) };\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  }
]
